/*
 * Click nbfs://nbhost/SystemFileSystem/Templates/Licenses/license-default.txt to change this license
 * Click nbfs://nbhost/SystemFileSystem/Templates/GUIForms/JFrame.java to edit this template
 */

/**
 *
 * @author johncalen.nombrado
 */

import javax.swing.JButton;
import javax.swing.JFrame;
import javax.swing.JLabel;
import javax.swing.JOptionPane;
import javax.swing.JPanel;
import javax.swing.JTextField;
import javax.swing.JProgressBar;
import javax.swing.JScrollPane;
import javax.swing.BoxLayout;
import javax.swing.SwingUtilities;
import java.awt.BorderLayout;
import java.awt.Color;
import java.awt.Component;
import java.awt.Dimension;
import java.awt.FlowLayout;
import java.awt.Font;
import java.awt.GridLayout;
import java.util.List;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.util.ArrayList;
import java.util.Comparator;
import java.util.HashMap;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.Map;
import java.util.Queue;
import javax.swing.BorderFactory;
import javax.swing.Box;
import javax.swing.JScrollBar;
import javax.swing.SwingConstants;
import javax.swing.SwingWorker;

public class NewJFrame extends javax.swing.JFrame {

    /**
     * Creates new form NewJFrame
     * 
     */
    
    private JTextField numProcField;
    private List<Process> processList = new ArrayList<>();
    private String selectedAlgorithm = "FIFO"; // Default
    private volatile int simulationDelay = 500;  // default value

    public NewJFrame() {
    initComponents();
    setResizable(false);
    
    jPanel1.setVisible(false);
    
    jComboBox1.addActionListener(e -> {
    boolean isMLFQ = jComboBox1.getSelectedItem().toString().equals("MLFQ");

    tqQ0Field.setVisible(isMLFQ);
    allQ0Field.setVisible(isMLFQ);
    tqQ1Field.setVisible(isMLFQ);
    allQ1Field.setVisible(isMLFQ);
    tqQ2Field.setVisible(isMLFQ);
    allQ2Field.setVisible(isMLFQ);

    // Updated label variables based on your naming
    Q1Q.setVisible(isMLFQ); // Q0 Quantum Label
    Q1A.setVisible(isMLFQ); // Q0 Allotment Label
    Q2Q.setVisible(isMLFQ); // Q1 Quantum Label
    Q2A.setVisible(isMLFQ); // Q1 Allotment Label
    Q3Q.setVisible(isMLFQ); // Q2 Quantum Label
    Q3A.setVisible(isMLFQ); // Q2 Allotment Label

    jPanel1.revalidate();
    jPanel1.repaint();
});
    
    // 🆕 Simulation speed slider setup
    simulationSpeed.setMinimum(10);
    simulationSpeed.setMaximum(1000);
    simulationSpeed.setValue(500); // default speed: 500 ms
    simulationSpeed.setMajorTickSpacing(250);
    simulationSpeed.setMinorTickSpacing(50);
    simulationSpeed.setPaintTicks(true);
    simulationSpeed.setPaintLabels(true);

    simulationSpeed.addChangeListener(e -> {
        simulationDelay = simulationSpeed.getValue();
    });

    // Existing setup
    jComboBox1.setModel(new javax.swing.DefaultComboBoxModel<>(new String[] {
        "First-In First-Out (FIFO/FCFS)",
        "Shortest Job First (SJF) Non-Preemptive",
        "Shortest Remaining Time First (SRTF) Preemptive",
        "Round Robin (RR)",
        "Multilevel Feedback Queue (MLFQ)"
    }));

     processPanel.setLayout(new GridLayout(0, 1, 5, 5));
     queuePanel.setLayout(new FlowLayout(FlowLayout.LEFT));

     ganttPanel.setLayout(new BoxLayout(ganttPanel, BoxLayout.X_AXIS));
     jScrollPane5.setViewportView(ganttPanel);
    }
    
    

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {
        java.awt.GridBagConstraints gridBagConstraints;

        jComboBox1 = new javax.swing.JComboBox<>();
        jLabel4 = new javax.swing.JLabel();
        jScrollPane1 = new javax.swing.JScrollPane();
        jTable1 = new javax.swing.JTable();
        Enter = new javax.swing.JButton();
        UserInput = new javax.swing.JTextField();
        jLabel1 = new javax.swing.JLabel();
        jScrollPane2 = new javax.swing.JScrollPane();
        processPanel = new javax.swing.JPanel();
        jLabel2 = new javax.swing.JLabel();
        jLabel3 = new javax.swing.JLabel();
        jLabel5 = new javax.swing.JLabel();
        RunButton = new javax.swing.JToggleButton();
        jLabel6 = new javax.swing.JLabel();
        jLabel7 = new javax.swing.JLabel();
        jScrollPane3 = new javax.swing.JScrollPane();
        queuePanel = new javax.swing.JPanel();
        jScrollPane5 = new javax.swing.JScrollPane();
        ganttPanel = new javax.swing.JPanel();
        simulationSpeed = new javax.swing.JSlider();
        jLabel9 = new javax.swing.JLabel();
        jLabel8 = new javax.swing.JLabel();
        jLabel10 = new javax.swing.JLabel();
        jPanel1 = new javax.swing.JPanel();
        Q1Q = new javax.swing.JLabel();
        Q1A = new javax.swing.JLabel();
        Q2Q = new javax.swing.JLabel();
        Q2A = new javax.swing.JLabel();
        Q3Q = new javax.swing.JLabel();
        Q3A = new javax.swing.JLabel();
        tqQ0Field = new javax.swing.JTextField();
        allQ0Field = new javax.swing.JTextField();
        tqQ1Field = new javax.swing.JTextField();
        allQ1Field = new javax.swing.JTextField();
        tqQ2Field = new javax.swing.JTextField();
        allQ2Field = new javax.swing.JTextField();

        setDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE);

        jComboBox1.setModel(new javax.swing.DefaultComboBoxModel<>(new String[] { "First-In First-Out (FIFO/FCFS) ", "Shortest Job First (SJF) Non-Preemptive", "Shortest Remaining Time First (SRTF) Preemptive", "Round Robin (RR)", "Multilevel Feedback Queue (MLFQ)" }));
        jComboBox1.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jComboBox1ActionPerformed(evt);
            }
        });

        jLabel4.setFont(new java.awt.Font("Helvetica Neue", 1, 12)); // NOI18N
        jLabel4.setText("ALGORITHMS");

        jTable1.setModel(new javax.swing.table.DefaultTableModel(
            new Object [][] {
                {null, null, null, null, null, null, null, null},
                {null, null, null, null, null, null, null, null},
                {null, null, null, null, null, null, null, null},
                {null, null, null, null, null, null, null, null},
                {null, null, null, null, null, null, null, null},
                {null, null, null, null, null, null, null, null},
                {null, null, null, null, null, null, null, null},
                {null, null, null, null, null, null, null, null},
                {null, null, null, null, null, null, null, null},
                {null, null, null, null, null, null, null, null}
            },
            new String [] {
                "Process ID:", "Arrival Time", "Burst Time", "Completion Time", "Turnaround Time", "Response Time", "Average Turnaround Time", "Average Response Time"
            }
        ) {
            boolean[] canEdit = new boolean [] {
                false, false, false, false, false, false, false, false
            };

            public boolean isCellEditable(int rowIndex, int columnIndex) {
                return canEdit [columnIndex];
            }
        });
        jScrollPane1.setViewportView(jTable1);

        Enter.setText("Enter");
        Enter.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                EnterActionPerformed(evt);
            }
        });

        UserInput.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                UserInputActionPerformed(evt);
            }
        });

        jLabel1.setFont(new java.awt.Font("Helvetica Neue", 1, 11)); // NOI18N
        jLabel1.setText("How many process?");

        processPanel.setBackground(new java.awt.Color(255, 255, 255));
        processPanel.setBorder(javax.swing.BorderFactory.createBevelBorder(javax.swing.border.BevelBorder.RAISED));

        javax.swing.GroupLayout processPanelLayout = new javax.swing.GroupLayout(processPanel);
        processPanel.setLayout(processPanelLayout);
        processPanelLayout.setHorizontalGroup(
            processPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 276, Short.MAX_VALUE)
        );
        processPanelLayout.setVerticalGroup(
            processPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 347, Short.MAX_VALUE)
        );

        jScrollPane2.setViewportView(processPanel);

        jLabel2.setFont(new java.awt.Font("Helvetica Neue", 1, 12)); // NOI18N
        jLabel2.setText("PID");

        jLabel3.setFont(new java.awt.Font("Helvetica Neue", 1, 12)); // NOI18N
        jLabel3.setText("Progress");

        jLabel5.setFont(new java.awt.Font("Helvetica Neue", 1, 12)); // NOI18N
        jLabel5.setText("State");

        RunButton.setText("Run");
        RunButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                RunButtonActionPerformed(evt);
            }
        });

        jLabel6.setFont(new java.awt.Font("Helvetica Neue", 1, 13)); // NOI18N

        jLabel7.setFont(new java.awt.Font("Helvetica Neue", 1, 18)); // NOI18N
        jLabel7.setText("Queue:");

        jScrollPane3.setBorder(javax.swing.BorderFactory.createBevelBorder(javax.swing.border.BevelBorder.RAISED));

        queuePanel.setBackground(new java.awt.Color(255, 255, 255));
        queuePanel.setBorder(javax.swing.BorderFactory.createBevelBorder(javax.swing.border.BevelBorder.RAISED));

        javax.swing.GroupLayout queuePanelLayout = new javax.swing.GroupLayout(queuePanel);
        queuePanel.setLayout(queuePanelLayout);
        queuePanelLayout.setHorizontalGroup(
            queuePanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 216, Short.MAX_VALUE)
        );
        queuePanelLayout.setVerticalGroup(
            queuePanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 120, Short.MAX_VALUE)
        );

        jScrollPane3.setViewportView(queuePanel);

        jScrollPane5.setBackground(new java.awt.Color(255, 255, 255));
        jScrollPane5.setBorder(javax.swing.BorderFactory.createBevelBorder(javax.swing.border.BevelBorder.RAISED));

        ganttPanel.setBackground(new java.awt.Color(255, 255, 255));
        ganttPanel.setBorder(javax.swing.BorderFactory.createBevelBorder(javax.swing.border.BevelBorder.RAISED));

        javax.swing.GroupLayout ganttPanelLayout = new javax.swing.GroupLayout(ganttPanel);
        ganttPanel.setLayout(ganttPanelLayout);
        ganttPanelLayout.setHorizontalGroup(
            ganttPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 1011, Short.MAX_VALUE)
        );
        ganttPanelLayout.setVerticalGroup(
            ganttPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 100, Short.MAX_VALUE)
        );

        jScrollPane5.setViewportView(ganttPanel);

        jLabel9.setFont(new java.awt.Font("Helvetica Neue", 1, 18)); // NOI18N
        jLabel9.setText("Simulation Speed");

        jLabel8.setText("Gantt Chart ");
        jLabel8.setToolTipText("");
        jLabel8.setRequestFocusEnabled(false);

        jLabel10.setText("(Each box represents completionTime)");

        jPanel1.setBackground(new java.awt.Color(255, 255, 255));
        jPanel1.setLayout(new java.awt.GridBagLayout());

        Q1Q.setText("Q0 Quantum:");
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 0;
        gridBagConstraints.gridy = 0;
        gridBagConstraints.ipadx = 4;
        gridBagConstraints.anchor = java.awt.GridBagConstraints.NORTHWEST;
        gridBagConstraints.insets = new java.awt.Insets(9, 6, 0, 0);
        jPanel1.add(Q1Q, gridBagConstraints);

        Q1A.setText("Q0 Allotment:");
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 0;
        gridBagConstraints.gridy = 2;
        gridBagConstraints.anchor = java.awt.GridBagConstraints.NORTHWEST;
        gridBagConstraints.insets = new java.awt.Insets(9, 6, 0, 0);
        jPanel1.add(Q1A, gridBagConstraints);

        Q2Q.setText("Q1 Quantum:");
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 0;
        gridBagConstraints.gridy = 4;
        gridBagConstraints.ipadx = 4;
        gridBagConstraints.anchor = java.awt.GridBagConstraints.NORTHWEST;
        gridBagConstraints.insets = new java.awt.Insets(9, 6, 0, 0);
        jPanel1.add(Q2Q, gridBagConstraints);

        Q2A.setText("Q1 Allotment:");
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 0;
        gridBagConstraints.gridy = 6;
        gridBagConstraints.anchor = java.awt.GridBagConstraints.NORTHWEST;
        gridBagConstraints.insets = new java.awt.Insets(9, 6, 0, 0);
        jPanel1.add(Q2A, gridBagConstraints);

        Q3Q.setText("Q2 Quantum:");
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 0;
        gridBagConstraints.gridy = 8;
        gridBagConstraints.ipadx = 4;
        gridBagConstraints.anchor = java.awt.GridBagConstraints.NORTHWEST;
        gridBagConstraints.insets = new java.awt.Insets(9, 6, 0, 0);
        jPanel1.add(Q3Q, gridBagConstraints);

        Q3A.setText("Q2 Allotment:");
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 0;
        gridBagConstraints.gridy = 10;
        gridBagConstraints.anchor = java.awt.GridBagConstraints.NORTHWEST;
        gridBagConstraints.insets = new java.awt.Insets(9, 6, 0, 0);
        jPanel1.add(Q3A, gridBagConstraints);

        tqQ0Field.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                tqQ0FieldActionPerformed(evt);
            }
        });
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 1;
        gridBagConstraints.gridy = 0;
        gridBagConstraints.gridheight = 2;
        gridBagConstraints.ipadx = -18;
        gridBagConstraints.anchor = java.awt.GridBagConstraints.NORTHWEST;
        gridBagConstraints.insets = new java.awt.Insets(6, 6, 0, 6);
        jPanel1.add(tqQ0Field, gridBagConstraints);
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 1;
        gridBagConstraints.gridy = 2;
        gridBagConstraints.gridheight = 2;
        gridBagConstraints.ipadx = -18;
        gridBagConstraints.anchor = java.awt.GridBagConstraints.NORTHWEST;
        gridBagConstraints.insets = new java.awt.Insets(6, 6, 0, 6);
        jPanel1.add(allQ0Field, gridBagConstraints);
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 1;
        gridBagConstraints.gridy = 4;
        gridBagConstraints.gridheight = 2;
        gridBagConstraints.ipadx = -18;
        gridBagConstraints.anchor = java.awt.GridBagConstraints.NORTHWEST;
        gridBagConstraints.insets = new java.awt.Insets(6, 6, 0, 6);
        jPanel1.add(tqQ1Field, gridBagConstraints);
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 1;
        gridBagConstraints.gridy = 6;
        gridBagConstraints.gridheight = 2;
        gridBagConstraints.ipadx = -18;
        gridBagConstraints.anchor = java.awt.GridBagConstraints.NORTHWEST;
        gridBagConstraints.insets = new java.awt.Insets(6, 6, 0, 6);
        jPanel1.add(allQ1Field, gridBagConstraints);
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 1;
        gridBagConstraints.gridy = 8;
        gridBagConstraints.gridheight = 2;
        gridBagConstraints.ipadx = -18;
        gridBagConstraints.anchor = java.awt.GridBagConstraints.NORTHWEST;
        gridBagConstraints.insets = new java.awt.Insets(6, 6, 0, 6);
        jPanel1.add(tqQ2Field, gridBagConstraints);
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 1;
        gridBagConstraints.gridy = 10;
        gridBagConstraints.gridheight = 2;
        gridBagConstraints.ipadx = -18;
        gridBagConstraints.anchor = java.awt.GridBagConstraints.NORTHWEST;
        gridBagConstraints.insets = new java.awt.Insets(6, 6, 15, 6);
        jPanel1.add(allQ2Field, gridBagConstraints);

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(layout.createSequentialGroup()
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING)
                            .addGroup(layout.createSequentialGroup()
                                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                                    .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, layout.createSequentialGroup()
                                        .addComponent(jLabel1)
                                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                                        .addComponent(UserInput, javax.swing.GroupLayout.PREFERRED_SIZE, 99, javax.swing.GroupLayout.PREFERRED_SIZE)
                                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                                        .addComponent(Enter)
                                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED))
                                    .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, layout.createSequentialGroup()
                                        .addComponent(jLabel6)
                                        .addGap(140, 140, 140)))
                                .addComponent(RunButton, javax.swing.GroupLayout.PREFERRED_SIZE, 72, javax.swing.GroupLayout.PREFERRED_SIZE))
                            .addGroup(layout.createSequentialGroup()
                                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING)
                                    .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                                        .addComponent(jComboBox1, javax.swing.GroupLayout.PREFERRED_SIZE, 142, javax.swing.GroupLayout.PREFERRED_SIZE)
                                        .addComponent(jLabel4))
                                    .addComponent(jPanel1, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, false)
                                    .addComponent(jScrollPane2, javax.swing.GroupLayout.PREFERRED_SIZE, 280, javax.swing.GroupLayout.PREFERRED_SIZE)
                                    .addGroup(layout.createSequentialGroup()
                                        .addComponent(jLabel2)
                                        .addGap(78, 78, 78)
                                        .addComponent(jLabel3)
                                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                                        .addComponent(jLabel5)
                                        .addGap(12, 12, 12)))))
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addComponent(jScrollPane1)
                            .addGroup(layout.createSequentialGroup()
                                .addComponent(jLabel7)
                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                                .addComponent(jScrollPane3, javax.swing.GroupLayout.PREFERRED_SIZE, 218, javax.swing.GroupLayout.PREFERRED_SIZE)
                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                                    .addComponent(simulationSpeed, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                                    .addGroup(layout.createSequentialGroup()
                                        .addGap(24, 24, 24)
                                        .addComponent(jLabel9)))
                                .addGap(0, 0, Short.MAX_VALUE))))
                    .addGroup(layout.createSequentialGroup()
                        .addGap(50, 50, 50)
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addComponent(jScrollPane5, javax.swing.GroupLayout.PREFERRED_SIZE, 1023, javax.swing.GroupLayout.PREFERRED_SIZE)
                            .addGroup(layout.createSequentialGroup()
                                .addComponent(jLabel8)
                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                                .addComponent(jLabel10)))
                        .addGap(0, 44, Short.MAX_VALUE)))
                .addContainerGap())
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addGap(11, 11, 11)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(jLabel4)
                    .addComponent(jLabel2)
                    .addComponent(jLabel3)
                    .addComponent(jLabel5))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(layout.createSequentialGroup()
                        .addComponent(jScrollPane1, javax.swing.GroupLayout.PREFERRED_SIZE, 155, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addGap(13, 13, 13)
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addGroup(layout.createSequentialGroup()
                                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                                    .addGroup(layout.createSequentialGroup()
                                        .addGap(17, 17, 17)
                                        .addComponent(jLabel7))
                                    .addGroup(layout.createSequentialGroup()
                                        .addComponent(jLabel9)
                                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                                        .addComponent(simulationSpeed, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)))
                                .addGap(0, 0, Short.MAX_VALUE))
                            .addComponent(jScrollPane3, javax.swing.GroupLayout.PREFERRED_SIZE, 0, Short.MAX_VALUE)))
                    .addGroup(layout.createSequentialGroup()
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, false)
                            .addComponent(jScrollPane2, javax.swing.GroupLayout.PREFERRED_SIZE, 226, javax.swing.GroupLayout.PREFERRED_SIZE)
                            .addGroup(layout.createSequentialGroup()
                                .addComponent(jComboBox1, javax.swing.GroupLayout.PREFERRED_SIZE, 37, javax.swing.GroupLayout.PREFERRED_SIZE)
                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                                .addComponent(jPanel1, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)))
                        .addGap(0, 15, Short.MAX_VALUE)))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(jLabel1)
                    .addComponent(UserInput, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(Enter)
                    .addComponent(RunButton))
                .addGap(59, 59, 59)
                .addComponent(jLabel6)
                .addGap(26, 26, 26)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(jLabel8)
                    .addComponent(jLabel10))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(jScrollPane5, javax.swing.GroupLayout.PREFERRED_SIZE, 90, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addGap(30, 30, 30))
        );

        pack();
    }// </editor-fold>//GEN-END:initComponents

    private void jComboBox1ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jComboBox1ActionPerformed
        String selected = ((String) jComboBox1.getSelectedItem()).trim();

    String algorithmKey = switch (selected) {
        case "First-In First-Out (FIFO/FCFS)" -> "FIFO";
        case "Shortest Job First (SJF) Non-Preemptive" -> "SJF";
        case "Shortest Remaining Time First (SRTF) Preemptive" -> "SRTF";
        case "Round Robin (RR)" -> "RR";
        case "Multilevel Feedback Queue (MLFQ)" -> "MLFQ";
        default -> "UNKNOWN";
    };

    if (!algorithmKey.equals(selectedAlgorithm)) {
        selectedAlgorithm = algorithmKey;
        processList.clear();

        // Clear progress bars
        processPanel.removeAll();
        processPanel.revalidate();
        processPanel.repaint();

        // Clear table
        ((javax.swing.table.DefaultTableModel) jTable1.getModel()).setRowCount(0);

        // Clear queue panel
        queuePanel.removeAll();
        queuePanel.revalidate();
        queuePanel.repaint();

        // Clear Gantt chart
        ganttPanel.removeAll();
        ganttPanel.revalidate();
        ganttPanel.repaint();

        UserInput.setText("");
        RunButton.setSelected(false);
        JOptionPane.showMessageDialog(this, "Switched to: " + selected + ". Enter new process info.");
    }
       boolean isMLFQ = selectedAlgorithm.equals("MLFQ");

        jPanel1.setVisible(isMLFQ); // Show if MLFQ is selected, otherwise hide
        jPanel1.revalidate();
        jPanel1.repaint();

// Optional: Pre-fill or clear values
        if (isMLFQ) {
        tqQ0Field.setText("4");
        allQ0Field.setText("6");
        tqQ1Field.setText("6");
        allQ1Field.setText("10");
        tqQ2Field.setText("8");
        allQ2Field.setText("14");
        } else {
        tqQ0Field.setText("");
        allQ0Field.setText("");
        tqQ1Field.setText("");
        allQ1Field.setText("");
        tqQ2Field.setText("");
        allQ2Field.setText("");
        } 
    }//GEN-LAST:event_jComboBox1ActionPerformed

    private void EnterActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_EnterActionPerformed
        // TODO add your handling code here:
    processPanel.removeAll();  // Clear UI
    processList = new ArrayList<>(); // Reset data list

    int numProcesses;
    try {
        numProcesses = Integer.parseInt(UserInput.getText());
        if (numProcesses < 1 || numProcesses > 20) {
            throw new NumberFormatException();
        }
    } catch (NumberFormatException ex) {
        JOptionPane.showMessageDialog(this, "Enter a valid number between 1 and 20.");
        return;
    }

    for (int i = 1; i <= numProcesses; i++) {
        try {
            String arrivalStr = JOptionPane.showInputDialog("Enter Arrival Time for P" + i + ":");
            if (arrivalStr == null) {
                JOptionPane.showMessageDialog(this, "Input cancelled. Returning to main screen.");
                return; // exit the method gracefully
            }

            int arrival = Integer.parseInt(arrivalStr);

            String burstStr = JOptionPane.showInputDialog("Enter Burst Time for P" + i + ":");
            if (burstStr == null) {
                JOptionPane.showMessageDialog(this, "Input cancelled. Returning to main screen.");
                return;
            }

            int burst = Integer.parseInt(burstStr);

            // Create and store process
            Process p = new Process(i, arrival, burst);

            // Create corresponding row in UI
            JPanel row = new JPanel(new BorderLayout(5, 5));
            JLabel pidLabel = new JLabel("P" + i);
            JProgressBar progressBar = new JProgressBar();
            progressBar.setStringPainted(true);
            progressBar.setValue(0);
            JLabel stateLabel = new JLabel("Ready");

            // Attach components to process
            p.progressBar = progressBar;
            p.stateLabel = stateLabel;

            // Add to list and panel
            processList.add(p);
            row.add(pidLabel, BorderLayout.WEST);
            row.add(progressBar, BorderLayout.CENTER);
            row.add(stateLabel, BorderLayout.EAST);
            stateLabel.setBorder(javax.swing.BorderFactory.createEmptyBorder(0, 0, 0, 15));

            processPanel.add(row);
        } catch (NumberFormatException e) {
            JOptionPane.showMessageDialog(this, "Invalid input. Please enter numeric values.");
            i--; // Retry this process
        }
    }

    processPanel.revalidate();
    processPanel.repaint();
    }//GEN-LAST:event_EnterActionPerformed

    private void UserInputActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_UserInputActionPerformed
        // TODO add your handling code here:
       
    }//GEN-LAST:event_UserInputActionPerformed

    private void RunButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_RunButtonActionPerformed
         if (processList == null || processList.isEmpty()) {
        JOptionPane.showMessageDialog(this, "Please enter processes first.");
        return;
    }

    // Disable input during run
    Enter.setEnabled(false);
    UserInput.setEnabled(false);
    RunButton.setEnabled(false);

    // Run selected algorithm
    switch (selectedAlgorithm) {
        case "FIFO":
            runFIFO();
            break;
        case "SJF":
            runSJF();
            break;
        case "SRTF":
            runSRTF();
            break;
        case "RR":
            runRR();
            break;
        case "MLFQ":
            runMLFQ();
            break;
        default:
            JOptionPane.showMessageDialog(this, "Unknown algorithm selected.");
            Enter.setEnabled(true);
            UserInput.setEnabled(true);
            RunButton.setEnabled(true);
         } 
    }//GEN-LAST:event_RunButtonActionPerformed

    private void tqQ0FieldActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_tqQ0FieldActionPerformed
        // TODO add your handling code here:
    }//GEN-LAST:event_tqQ0FieldActionPerformed

    private void runFIFO() {
    // Sort by arrival time
 processList.sort((p1, p2) -> Integer.compare(p1.arrivalTime, p2.arrivalTime));

    // Clear Gantt chart and update queue before simulation
    SwingUtilities.invokeLater(() -> {
        updateQueueDisplay(processList);
        ganttPanel.removeAll();
        ganttPanel.revalidate();
        ganttPanel.repaint();
    });

    new Thread(() -> {
        int[] currentTime = {0};  // mutable for lambda use
        int[] totalTAT = {0};
        int[] totalRT = {0};

        for (int i = 0; i < processList.size(); i++) {
            Process p = processList.get(i);

            // Simulate idle time (if CPU is waiting for process to arrive)
            if (currentTime[0] < p.arrivalTime) {
                try {
                    Thread.sleep((p.arrivalTime - currentTime[0]) * simulationDelay);
                } catch (InterruptedException e) {}
                currentTime[0] = p.arrivalTime;
            }

            // Update the remaining queue display
            int finalI = i;
            SwingUtilities.invokeLater(() -> {
                List<Process> remainingQueue = processList.subList(finalI, processList.size());
                updateQueueDisplay(remainingQueue);
            });

            int finalIndex = i;
            int startTime = currentTime[0];
            int burst = p.burstTime;

            SwingWorker<Void, Integer> worker = new SwingWorker<>() {
                @Override
                protected Void doInBackground() throws Exception {
                    p.stateLabel.setText("Running");
                    for (int t = 1; t <= burst; t++) {
                        Thread.sleep(simulationDelay); // ⏳ dynamic delay
                        publish(t * 100 / burst); // update progress
                    }
                    publish(100);
                    return null;
                }

                @Override
                protected void process(List<Integer> chunks) {
                    int value = chunks.get(chunks.size() - 1);
                    p.progressBar.setValue(value);
                }

                @Override
                protected void done() {
                     SwingUtilities.invokeLater(() -> {
                        p.progressBar.setValue(100);
                        p.stateLabel.setText("Done");

                        currentTime[0] = startTime + burst;
                        p.responseTime = startTime - p.arrivalTime;
                        p.completionTime = currentTime[0];
                        p.turnaroundTime = p.completionTime - p.arrivalTime;

                        totalRT[0] += p.responseTime;
                        totalTAT[0] += p.turnaroundTime;

                        // ✅ Gantt update immediately
                        updateGanttChart(startTime, currentTime[0], p.pid);

                        // Update remaining queue
                        if (finalIndex + 1 < processList.size()) {
                            updateQueueDisplay(processList.subList(finalIndex + 1, processList.size()));
                        } else {
                            updateQueueDisplay(new ArrayList<>());
                        }

                        // Enable UI after final process
                        if (finalIndex == processList.size() - 1) {
                            updateTable(totalTAT[0], totalRT[0]);
                            Enter.setEnabled(true);
                            UserInput.setEnabled(true);
                            RunButton.setEnabled(true);
                            RunButton.setSelected(false);
                        }
                    });
                }
            };

            worker.execute();

            try {
                // Wait for process to complete before next
                while (!worker.isDone()) {
                    Thread.sleep(simulationDelay); // ⏳ dynamic check delay
                }
            } catch (InterruptedException e) {}
        }
    }).start();
}
    
    private void runSJF() {
      new Thread(() -> {
        List<Process> readyQueue = new ArrayList<>();
        int time = 0;
        int completed = 0;
        int n = processList.size();
        int[] totalRT = {0};
        int[] totalTAT = {0};

        // Initialize all processes
        for (Process p : processList) {
            p.remainingTime = p.burstTime;
            p.started = false;
        }

        // Sort by arrival time then burst time
        processList.sort((p1, p2) -> {
            if (p1.arrivalTime != p2.arrivalTime) {
                return Integer.compare(p1.arrivalTime, p2.arrivalTime);
            }
            return Integer.compare(p1.burstTime, p2.burstTime);
        });

        // Clear Gantt chart before start
        SwingUtilities.invokeLater(() -> {
            ganttPanel.removeAll();
            ganttPanel.revalidate();
            ganttPanel.repaint();
        });

        while (completed < n) {
            // Fill ready queue
            readyQueue.clear();
            for (Process p : processList) {
                if (!p.started && p.arrivalTime <= time) {
                    readyQueue.add(p);
                }
            }

            // Update queue display
            List<Process> displayQueue = new ArrayList<>(readyQueue);
            SwingUtilities.invokeLater(() -> updateQueueDisplay(displayQueue));

            // No ready processes, idle
            if (readyQueue.isEmpty()) {
                time++;
                try {
                    Thread.sleep(simulationDelay); // ⏳ idle wait
                } catch (InterruptedException ignored) {}
                continue;
            }

            // Select shortest job
            readyQueue.sort((p1, p2) -> Integer.compare(p1.burstTime, p2.burstTime));
            Process current = readyQueue.get(0);
            current.started = true;

            int start = time;
            int end = time + current.burstTime;

            // Record response & turnaround
            current.responseTime = start - current.arrivalTime;
            current.completionTime = end;
            current.turnaroundTime = end - current.arrivalTime;
            totalRT[0] += current.responseTime;
            totalTAT[0] += current.turnaroundTime;

            Process finalCurrent = current;
            SwingUtilities.invokeLater(() -> finalCurrent.stateLabel.setText("Running"));

            // Simulate execution
            for (int t = 0; t < current.burstTime; t++) {
                try {
                    Thread.sleep(simulationDelay); // ⏳ dynamic speed
                } catch (InterruptedException ignored) {}

                int progress = (int) (((t + 1) / (float) current.burstTime) * 100);
                SwingUtilities.invokeLater(() -> finalCurrent.progressBar.setValue(progress));

                int finalTime = time + t + 1;

                // Refresh queue at each tick
                List<Process> tickQueue = new ArrayList<>();
                for (Process p : processList) {
                    if (!p.started && p.arrivalTime <= finalTime) {
                        tickQueue.add(p);
                    }
                }
                SwingUtilities.invokeLater(() -> updateQueueDisplay(tickQueue));
            }

            // Final UI update after process finishes
            SwingUtilities.invokeLater(() -> {
                finalCurrent.stateLabel.setText("Done");
                finalCurrent.progressBar.setValue(100);
                updateGanttChart(start, end, finalCurrent.pid);
            });

            time = end;
            completed++;
        }

        // All done — update table
        SwingUtilities.invokeLater(() -> {
            updateTable(totalTAT[0], totalRT[0]);
            Enter.setEnabled(true);
            UserInput.setEnabled(true);
            RunButton.setEnabled(true);
            RunButton.setSelected(false);
        });
    }).start();
}

    
    private void runSRTF() {
     new Thread(() -> {
        List<Process> readyQueue = new ArrayList<>();
        int time = 0;
        int completed = 0;
        int n = processList.size();
        int[] totalRT = {0};
        int[] totalTAT = {0};

        for (Process p : processList) {
            p.remainingTime = p.burstTime;
            p.started = false;
        }

        SwingUtilities.invokeLater(() -> {
            ganttPanel.removeAll();
            ganttPanel.revalidate();
            ganttPanel.repaint();
        });

        Process current = null;
        int start = -1;

        while (completed < n) {
            for (Process p : processList) {
                if (p.arrivalTime == time) {
                    readyQueue.add(p);
                }
            }

            Process shortest = null;
            for (Process p : readyQueue) {
                if (p.remainingTime > 0) {
                    if (shortest == null || p.remainingTime < shortest.remainingTime) {
                        shortest = p;
                    }
                }
            }

            if (shortest != null) {
                if (current != shortest) {
                    if (current != null && current.remainingTime > 0) {
                        Process finalOld = current;
                        SwingUtilities.invokeLater(() -> finalOld.stateLabel.setText("Ready"));
                    }

                    current = shortest;
                    start = time;

                    if (!current.started) {
                        current.started = true;
                        current.responseTime = time - current.arrivalTime;
                    }

                    Process finalCurrentStart = current;
                    SwingUtilities.invokeLater(() -> finalCurrentStart.stateLabel.setText("Running"));
                }

                Process finalCurrentTick = current;
                SwingUtilities.invokeLater(() -> {
                    finalCurrentTick.progressBar.setValue(
                        (int)(((finalCurrentTick.burstTime - finalCurrentTick.remainingTime + 1) * 100.0) / finalCurrentTick.burstTime)
                    );
                });

                current.remainingTime--;

                if (current.remainingTime == 0) {
                    // Final update occurs after current tick
                    Process finalCurrentDone = current;
                    int finalStart = start;
                    int finalEnd = time + 1;

                    current.completionTime = finalEnd;
                    current.turnaroundTime = finalCurrentDone.completionTime - finalCurrentDone.arrivalTime;
                    totalRT[0] += finalCurrentDone.responseTime;
                    totalTAT[0] += finalCurrentDone.turnaroundTime;

                    SwingUtilities.invokeLater(() -> {
                        finalCurrentDone.stateLabel.setText("Done");
                        finalCurrentDone.progressBar.setValue(100);
                        updateGanttChart(finalStart, finalEnd, finalCurrentDone.pid);
                    });

                    current = null;
                    completed++;
                }
            }

            List<Process> displayQueue = new ArrayList<>();
            for (Process p : readyQueue) {
                if (p.remainingTime > 0 && p != current) {
                    displayQueue.add(p);
                }
            }

            List<Process> finalQueue = new ArrayList<>(displayQueue);
            SwingUtilities.invokeLater(() -> updateQueueDisplay(finalQueue));

            try {
                Thread.sleep(simulationDelay); // ✅ delay tied to slider
            } catch (InterruptedException ignored) {}

            time++;
        }

        SwingUtilities.invokeLater(() -> {
            updateTable(totalTAT[0], totalRT[0]);
            Enter.setEnabled(true);
            UserInput.setEnabled(true);
            RunButton.setEnabled(true);
            RunButton.setSelected(false);
        });
    }).start();
}
    
    private void runRR() {
    String input = JOptionPane.showInputDialog(this, "Enter Time Quantum:", "Round Robin Settings", JOptionPane.QUESTION_MESSAGE);
    if (input == null) {
        reenableControls();
        return;
    }

    int timeQuantum;
    try {
        timeQuantum = Integer.parseInt(input);
        if (timeQuantum <= 0) throw new NumberFormatException();
    } catch (NumberFormatException e) {
        JOptionPane.showMessageDialog(this, "Invalid input. Please enter a positive integer.", "Error", JOptionPane.ERROR_MESSAGE);
        reenableControls();
        return;
    }

    new Thread(() -> {
        List<Process> readyQueue = new ArrayList<>();
        int time = 0, completed = 0, n = processList.size();
        int[] totalRT = {0}, totalTAT = {0};

        for (Process p : processList) {
            p.remainingTime = p.burstTime;
            p.started = false;
        }

        SwingUtilities.invokeLater(() -> {
            ganttPanel.removeAll();
            ganttPanel.revalidate();
            ganttPanel.repaint();
        });

        while (completed < n) {
            // 🆕 Clean up: avoid re-adding already completed processes
            for (Process p : processList) {
                if (p.arrivalTime <= time && p.remainingTime > 0 && !queueContains(readyQueue, p)) {
                    readyQueue.add(p);
                }
            }

            if (readyQueue.isEmpty()) {
                time++;
                try { Thread.sleep(simulationDelay); } catch (InterruptedException ignored) {}
                continue;
            }

            Process current = readyQueue.remove(0);
            if (current.remainingTime <= 0) continue; // Skip finished

            int execTime = Math.min(timeQuantum, current.remainingTime);
            int startTime = time;

            if (!current.started) {
                current.started = true;
                current.responseTime = time - current.arrivalTime;
                totalRT[0] += current.responseTime;
            }

            Process finalCurrent = current;
            SwingUtilities.invokeLater(() -> finalCurrent.stateLabel.setText("Running"));

            for (int i = 0; i < execTime; i++) {
                try { Thread.sleep(simulationDelay); } catch (InterruptedException ignored) {}
                time++;
                current.remainingTime--;

                int progress = (int)(((float)(current.burstTime - current.remainingTime) / current.burstTime) * 100);
                SwingUtilities.invokeLater(() -> current.progressBar.setValue(progress));

                // Dynamically check for new arrivals
                for (Process p : processList) {
                    if (p.arrivalTime == time && p.remainingTime > 0 && !queueContains(readyQueue, p)) {
                        readyQueue.add(p);
                    }
                }
            }

            int endTime = time;

            // 🎯 Sync Gantt with actual execution
            if (startTime != endTime) {
                SwingUtilities.invokeLater(() -> {
                    finalCurrent.stateLabel.setText(finalCurrent.remainingTime == 0 ? "Done" : "Ready");
                    if (finalCurrent.remainingTime == 0) finalCurrent.progressBar.setValue(100);
                    updateGanttChart(startTime, endTime, finalCurrent.pid);
                });
            }

            if (current.remainingTime > 0) {
                // ✔️ Avoid requeueing duplicates
                if (!queueContains(readyQueue, current)) {
                    readyQueue.add(current);
                }
            } else {
                current.completionTime = time;
                current.turnaroundTime = current.completionTime - current.arrivalTime;
                totalTAT[0] += current.turnaroundTime;
                completed++;
            }

            // ✅ Filter queue for active processes only (no repeats)
            List<Process> queueDisplay = new ArrayList<>();
            for (Process p : readyQueue) {
                if (p.remainingTime > 0 && !queueDisplay.contains(p)) {
                    queueDisplay.add(p);
                }
            }

            SwingUtilities.invokeLater(() -> updateQueueDisplay(queueDisplay));
        }

        SwingUtilities.invokeLater(() -> {
            updateTable(totalTAT[0], totalRT[0]);
            reenableControls();
        });
    }).start();
    }
    
 
    private void runMLFQ() {
    if (processList == null || processList.isEmpty()) {
        JOptionPane.showMessageDialog(this, "No processes found. Please enter processes first.");
        return;
    }

    // Retrieve quantum and allotment values from input fields
    int tqQ0 = Integer.parseInt(tqQ0Field.getText());
    int allQ0 = Integer.parseInt(allQ0Field.getText());
    int tqQ1 = Integer.parseInt(tqQ1Field.getText());
    int allQ1 = Integer.parseInt(allQ1Field.getText());
    int tqQ2 = Integer.parseInt(tqQ2Field.getText());
    int allQ2 = Integer.parseInt(allQ2Field.getText());

    List<Queue<Process>> queues = new ArrayList<>();
    for (int i = 0; i < 4; i++) queues.add(new LinkedList<>());

    // Reset process fields
    for (Process p : processList) {
        p.remainingTime = p.burstTime;
        p.queueLevel = 0;
        p.usedTime = 0;
        p.started = false;
    }

    ganttPanel.removeAll();
    ganttPanel.revalidate();
    ganttPanel.repaint();

    int time = 0;
    List<Process> ready = new ArrayList<>(processList);
    ready.sort(Comparator.comparingInt(p -> p.arrivalTime));

    while (!ready.isEmpty() || queues.stream().anyMatch(q -> !q.isEmpty())) {
        // Enqueue newly arrived processes to Q0
        Iterator<Process> it = ready.iterator();
        while (it.hasNext()) {
            Process p = it.next();
            if (p.arrivalTime <= time) {
                p.queueLevel = 0;
                p.usedTime = 0;
                queues.get(0).offer(p);
                it.remove();
            }
        }

        // Pick the highest priority non-empty queue
        Process running = null;
        int qIndex = -1;
        for (int i = 0; i < 4; i++) {
            if (!queues.get(i).isEmpty()) {
                running = queues.get(i).poll();
                qIndex = i;
                break;
            }
        }

        if (running == null) {
            time++;
            continue;
        }

        int qt = (qIndex == 0) ? tqQ0 : (qIndex == 1) ? tqQ1 : (qIndex == 2) ? tqQ2 : Integer.MAX_VALUE;
        int allot = (qIndex == 0) ? allQ0 : (qIndex == 1) ? allQ1 : (qIndex == 2) ? allQ2 : Integer.MAX_VALUE;

        int runTime = Math.min(qt, running.remainingTime);
        int endTime = time + runTime;

        // Record response time
        if (!running.started) {
            running.started = true;
            running.responseTime = time - running.arrivalTime;
        }

        // Visualize on Gantt chart
        addToGanttChart(running, time, endTime, qIndex);

        // Optional: simulate passage of time with delay
        for (int t = time; t < endTime; t++) {
            try {
                Thread.sleep(simulationDelay);
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
            }
        }

        running.remainingTime -= runTime;
        running.usedTime += runTime;
        time += runTime;

        if (running.remainingTime > 0) {
            // Check for demotion
            if (running.usedTime >= allot && qIndex < 3) {
                running.queueLevel = qIndex + 1;
                running.usedTime = 0;
                queues.get(running.queueLevel).offer(running);
            } else {
                queues.get(qIndex).offer(running);
            }
        } else {
            running.completionTime = time;
            running.turnaroundTime = time - running.arrivalTime;
        }
    }

    repaint(); // refresh UI
}

    

private void addToGanttChart(Process p, int start, int end, int queueLevel) {
    JLabel block = new JLabel(p.name + "[Q" + queueLevel + "]", SwingConstants.CENTER);
    block.setOpaque(true);
    block.setPreferredSize(new Dimension((end - start) * 30, 40)); // adjust scale as needed
    block.setBorder(BorderFactory.createLineBorder(Color.BLACK));
    block.setBackground(getColor(queueLevel));
    ganttPanel.add(block);
    ganttPanel.revalidate();
    ganttPanel.repaint();
}    

private Color getColor(int queueLevel) {
    switch (queueLevel) {
        case 0: return new Color(102, 204, 255); // Light Blue
        case 1: return new Color(153, 255, 153); // Light Green
        case 2: return new Color(255, 255, 153); // Light Yellow
        case 3: return new Color(255, 204, 204); // Light Red
        default: return Color.LIGHT_GRAY;
    }
}

// Utility method to re-enable UI buttons
private void reenableControls() {
    Enter.setEnabled(true);
    UserInput.setEnabled(true);
    RunButton.setEnabled(true);
    RunButton.setSelected(false);
}

    
    private void updateTable(int totalTAT, int totalRT) {
    javax.swing.table.DefaultTableModel model = (javax.swing.table.DefaultTableModel) jTable1.getModel();
    model.setRowCount(0);

    for (Process p : processList) {
        model.addRow(new Object[] {
            "P" + p.pid, p.arrivalTime, p.burstTime, p.completionTime,
            p.turnaroundTime, p.responseTime, "", ""
        });
    }

    float avgTAT = (float) totalTAT / processList.size();
    float avgRT = (float) totalRT / processList.size();

    model.addRow(new Object[] {
        "", "", "", "", "", "", String.format("%.2f", avgTAT), String.format("%.2f", avgRT)
    });
}
    
    private void updateQueueDisplay(List<Process> queue) {
    queuePanel.removeAll();
    for (Process p : queue) {
        JLabel label = new JLabel("P" + p.pid);
        label.setBorder(javax.swing.BorderFactory.createLineBorder(java.awt.Color.BLACK));
        label.setHorizontalAlignment(JLabel.CENTER);
        label.setOpaque(true);
        label.setBackground(java.awt.Color.LIGHT_GRAY);
        queuePanel.add(label);
    }
    queuePanel.revalidate();
    queuePanel.repaint();
}
    
    private void updateGanttChart(int startTime, int endTime, int pid) {
    JPanel block = new JPanel();
    block.setBorder(BorderFactory.createLineBorder(Color.BLACK));
    block.setBackground(Color.YELLOW);
    block.setLayout(new BoxLayout(block, BoxLayout.Y_AXIS)); // vertical layout

    // PID Label
    JLabel pidLabel = new JLabel("P" + pid);
    pidLabel.setFont(new Font("Arial", Font.BOLD, 14));
    pidLabel.setAlignmentX(Component.CENTER_ALIGNMENT);
    pidLabel.setHorizontalAlignment(SwingConstants.CENTER);

    // Time Label
    JLabel timeLabel = new JLabel("Running...");
    timeLabel.setFont(new Font("Arial", Font.PLAIN, 12));
    timeLabel.setAlignmentX(Component.CENTER_ALIGNMENT);
    timeLabel.setHorizontalAlignment(SwingConstants.CENTER);

    block.add(Box.createVerticalGlue()); // spacing above
    block.add(pidLabel);
    block.add(timeLabel);
    block.add(Box.createVerticalGlue()); // spacing below

    int blockWidth = Math.max((endTime - startTime) * 30, 50);
    block.setPreferredSize(new Dimension(blockWidth, ganttPanel.getHeight())); // 👈 full height of panel

    SwingUtilities.invokeLater(() -> {
        ganttPanel.add(block);
        ganttPanel.revalidate();
        ganttPanel.repaint();
    });

    // After execution, change color + show time range
    new Thread(() -> {
        try {
            Thread.sleep((endTime - startTime) * 500);
        } catch (InterruptedException ignored) {}

        SwingUtilities.invokeLater(() -> {
            block.setBackground(Color.CYAN);
            timeLabel.setText(startTime + " - " + endTime);
        });
    }).start();

    // Resize Gantt Panel width if needed
    SwingUtilities.invokeLater(() -> {
        int totalBlocks = ganttPanel.getComponentCount();
        int totalWidth = totalBlocks * (blockWidth + 5); // 5 = spacing
        ganttPanel.setPreferredSize(new Dimension(totalWidth, ganttPanel.getHeight()));
        ganttPanel.revalidate();
        ganttPanel.repaint();
    });
}


private boolean queueContains(List<Process> queue, Process target) {
    for (Process p : queue) {
        if (p.pid == target.pid) return true;
    }
    return false;
}
    /**
     * @param args the command line arguments
     */
    public static void main(String args[]) {
        /* Set the Nimbus look and feel */
        //<editor-fold defaultstate="collapsed" desc=" Look and feel setting code (optional) ">
        /* If Nimbus (introduced in Java SE 6) is not available, stay with the default look and feel.
         * For details see http://download.oracle.com/javase/tutorial/uiswing/lookandfeel/plaf.html 
         */
        try {
            for (javax.swing.UIManager.LookAndFeelInfo info : javax.swing.UIManager.getInstalledLookAndFeels()) {
                if ("Nimbus".equals(info.getName())) {
                    javax.swing.UIManager.setLookAndFeel(info.getClassName());
                    break;
                }
            }
        } catch (ClassNotFoundException ex) {
            java.util.logging.Logger.getLogger(NewJFrame.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (InstantiationException ex) {
            java.util.logging.Logger.getLogger(NewJFrame.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (IllegalAccessException ex) {
            java.util.logging.Logger.getLogger(NewJFrame.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (javax.swing.UnsupportedLookAndFeelException ex) {
            java.util.logging.Logger.getLogger(NewJFrame.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        }
        //</editor-fold>

        /* Create and display the form */
        java.awt.EventQueue.invokeLater(new Runnable() {
            public void run() {
                new NewJFrame().setVisible(true);
            }
        });
    }

    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JButton Enter;
    private javax.swing.JLabel Q1A;
    private javax.swing.JLabel Q1Q;
    private javax.swing.JLabel Q2A;
    private javax.swing.JLabel Q2Q;
    private javax.swing.JLabel Q3A;
    private javax.swing.JLabel Q3Q;
    private javax.swing.JToggleButton RunButton;
    private javax.swing.JTextField UserInput;
    private javax.swing.JTextField allQ0Field;
    private javax.swing.JTextField allQ1Field;
    private javax.swing.JTextField allQ2Field;
    private javax.swing.JPanel ganttPanel;
    private javax.swing.JComboBox<String> jComboBox1;
    private javax.swing.JLabel jLabel1;
    private javax.swing.JLabel jLabel10;
    private javax.swing.JLabel jLabel2;
    private javax.swing.JLabel jLabel3;
    private javax.swing.JLabel jLabel4;
    private javax.swing.JLabel jLabel5;
    private javax.swing.JLabel jLabel6;
    private javax.swing.JLabel jLabel7;
    private javax.swing.JLabel jLabel8;
    private javax.swing.JLabel jLabel9;
    private javax.swing.JPanel jPanel1;
    private javax.swing.JScrollPane jScrollPane1;
    private javax.swing.JScrollPane jScrollPane2;
    private javax.swing.JScrollPane jScrollPane3;
    private javax.swing.JScrollPane jScrollPane5;
    private javax.swing.JTable jTable1;
    private javax.swing.JPanel processPanel;
    private javax.swing.JPanel queuePanel;
    private javax.swing.JSlider simulationSpeed;
    private javax.swing.JTextField tqQ0Field;
    private javax.swing.JTextField tqQ1Field;
    private javax.swing.JTextField tqQ2Field;
    // End of variables declaration//GEN-END:variables
}
