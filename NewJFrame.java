/*
 * Click nbfs://nbhost/SystemFileSystem/Templates/Licenses/license-default.txt to change this license
 * Click nbfs://nbhost/SystemFileSystem/Templates/GUIForms/JFrame.java to edit this template
 */

/**
 *
 * @author johncalen.nombrado
 */

import javax.swing.JButton;
import javax.swing.JFrame;
import javax.swing.JLabel;
import javax.swing.JOptionPane;
import javax.swing.JPanel;
import javax.swing.JTextField;
import javax.swing.JProgressBar;
import javax.swing.JScrollPane;
import javax.swing.BoxLayout;
import javax.swing.SwingUtilities;
import java.awt.BorderLayout;
import java.awt.Color;
import java.awt.Component;
import java.awt.Dimension;
import java.awt.FlowLayout;
import java.awt.Font;
import java.awt.GridLayout;
import java.util.List;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.util.ArrayList;
import javax.swing.BorderFactory;
import javax.swing.Box;
import javax.swing.JScrollBar;
import javax.swing.SwingConstants;
import javax.swing.SwingWorker;

public class NewJFrame extends javax.swing.JFrame {

    /**
     * Creates new form NewJFrame
     * 
     */
    
    private JTextField numProcField;
    private List<Process> processList = new ArrayList<>();
    private String selectedAlgorithm = "FIFO"; // Default
    private volatile int simulationDelay = 500;  // default value

    public NewJFrame() {
    initComponents();
    setResizable(false);

    // 🆕 Simulation speed slider setup
    simulationSpeed.setMinimum(10);
    simulationSpeed.setMaximum(1000);
    simulationSpeed.setValue(500); // default speed: 500 ms
    simulationSpeed.setMajorTickSpacing(250);
    simulationSpeed.setMinorTickSpacing(50);
    simulationSpeed.setPaintTicks(true);
    simulationSpeed.setPaintLabels(true);

    simulationSpeed.addChangeListener(e -> {
        simulationDelay = simulationSpeed.getValue();
    });

    // Existing setup
    jComboBox1.setModel(new javax.swing.DefaultComboBoxModel<>(new String[] {
        "First-In First-Out (FIFO/FCFS)",
        "Shortest Job First (SJF) Non-Preemptive",
        "Shortest Remaining Time First (SRTF) Preemptive",
        "Round Robin (RR)",
        "Multilevel Feedback Queue (MLFQ)"
    }));

     processPanel.setLayout(new GridLayout(0, 1, 5, 5));
     queuePanel.setLayout(new FlowLayout(FlowLayout.LEFT));

     ganttPanel.setLayout(new BoxLayout(ganttPanel, BoxLayout.X_AXIS));
     jScrollPane5.setViewportView(ganttPanel);
    }
    
    

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        jComboBox1 = new javax.swing.JComboBox<>();
        jLabel4 = new javax.swing.JLabel();
        jScrollPane1 = new javax.swing.JScrollPane();
        jTable1 = new javax.swing.JTable();
        Enter = new javax.swing.JButton();
        UserInput = new javax.swing.JTextField();
        jLabel1 = new javax.swing.JLabel();
        jScrollPane2 = new javax.swing.JScrollPane();
        processPanel = new javax.swing.JPanel();
        jLabel2 = new javax.swing.JLabel();
        jLabel3 = new javax.swing.JLabel();
        jLabel5 = new javax.swing.JLabel();
        RunButton = new javax.swing.JToggleButton();
        jLabel6 = new javax.swing.JLabel();
        jLabel7 = new javax.swing.JLabel();
        jScrollPane3 = new javax.swing.JScrollPane();
        queuePanel = new javax.swing.JPanel();
        jScrollPane5 = new javax.swing.JScrollPane();
        ganttPanel = new javax.swing.JPanel();
        jLabel8 = new javax.swing.JLabel();
        simulationSpeed = new javax.swing.JSlider();
        jLabel9 = new javax.swing.JLabel();

        setDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE);

        jComboBox1.setModel(new javax.swing.DefaultComboBoxModel<>(new String[] { "First-In First-Out (FIFO/FCFS) ", "Shortest Job First (SJF) Non-Preemptive", "Shortest Remaining Time First (SRTF) Preemptive", "Round Robin (RR)", "Multilevel Feedback Queue (MLFQ)" }));
        jComboBox1.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jComboBox1ActionPerformed(evt);
            }
        });

        jLabel4.setFont(new java.awt.Font("Helvetica Neue", 1, 12)); // NOI18N
        jLabel4.setText("ALGORITHMS");

        jTable1.setModel(new javax.swing.table.DefaultTableModel(
            new Object [][] {
                {null, null, null, null, null, null, null, null},
                {null, null, null, null, null, null, null, null},
                {null, null, null, null, null, null, null, null},
                {null, null, null, null, null, null, null, null},
                {null, null, null, null, null, null, null, null},
                {null, null, null, null, null, null, null, null},
                {null, null, null, null, null, null, null, null},
                {null, null, null, null, null, null, null, null},
                {null, null, null, null, null, null, null, null},
                {null, null, null, null, null, null, null, null}
            },
            new String [] {
                "Process ID:", "Arrival Time", "Burst Time", "Completion Time", "Turnaround Time", "Response Time", "Average Turnaround Time", "Average Response Time"
            }
        ));
        jScrollPane1.setViewportView(jTable1);

        Enter.setText("Enter");
        Enter.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                EnterActionPerformed(evt);
            }
        });

        UserInput.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                UserInputActionPerformed(evt);
            }
        });

        jLabel1.setFont(new java.awt.Font("Helvetica Neue", 1, 10)); // NOI18N
        jLabel1.setText("How many process?");

        processPanel.setBackground(new java.awt.Color(255, 255, 255));
        processPanel.setBorder(javax.swing.BorderFactory.createBevelBorder(javax.swing.border.BevelBorder.RAISED));

        javax.swing.GroupLayout processPanelLayout = new javax.swing.GroupLayout(processPanel);
        processPanel.setLayout(processPanelLayout);
        processPanelLayout.setHorizontalGroup(
            processPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 276, Short.MAX_VALUE)
        );
        processPanelLayout.setVerticalGroup(
            processPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 347, Short.MAX_VALUE)
        );

        jScrollPane2.setViewportView(processPanel);

        jLabel2.setFont(new java.awt.Font("Helvetica Neue", 1, 13)); // NOI18N
        jLabel2.setText("PID");

        jLabel3.setFont(new java.awt.Font("Helvetica Neue", 1, 13)); // NOI18N
        jLabel3.setText("Progress");

        jLabel5.setFont(new java.awt.Font("Helvetica Neue", 1, 13)); // NOI18N
        jLabel5.setText("State");

        RunButton.setText("Run");
        RunButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                RunButtonActionPerformed(evt);
            }
        });

        jLabel6.setFont(new java.awt.Font("Helvetica Neue", 1, 13)); // NOI18N

        jLabel7.setFont(new java.awt.Font("Helvetica Neue", 1, 18)); // NOI18N
        jLabel7.setText("Queue:");

        jScrollPane3.setBorder(javax.swing.BorderFactory.createBevelBorder(javax.swing.border.BevelBorder.RAISED));

        queuePanel.setBackground(new java.awt.Color(255, 255, 255));
        queuePanel.setBorder(javax.swing.BorderFactory.createBevelBorder(javax.swing.border.BevelBorder.RAISED));

        javax.swing.GroupLayout queuePanelLayout = new javax.swing.GroupLayout(queuePanel);
        queuePanel.setLayout(queuePanelLayout);
        queuePanelLayout.setHorizontalGroup(
            queuePanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 216, Short.MAX_VALUE)
        );
        queuePanelLayout.setVerticalGroup(
            queuePanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 120, Short.MAX_VALUE)
        );

        jScrollPane3.setViewportView(queuePanel);

        javax.swing.GroupLayout ganttPanelLayout = new javax.swing.GroupLayout(ganttPanel);
        ganttPanel.setLayout(ganttPanelLayout);
        ganttPanelLayout.setHorizontalGroup(
            ganttPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 1011, Short.MAX_VALUE)
        );
        ganttPanelLayout.setVerticalGroup(
            ganttPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 100, Short.MAX_VALUE)
        );

        jScrollPane5.setViewportView(ganttPanel);

        jLabel8.setFont(new java.awt.Font("Helvetica Neue", 1, 10)); // NOI18N
        jLabel8.setText("GNATT CHART");

        jLabel9.setFont(new java.awt.Font("Helvetica Neue", 1, 18)); // NOI18N
        jLabel9.setText("Simulation Speed");

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addContainerGap()
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING)
                    .addGroup(layout.createSequentialGroup()
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addGroup(layout.createSequentialGroup()
                                .addComponent(jLabel1)
                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                                .addComponent(UserInput, javax.swing.GroupLayout.PREFERRED_SIZE, 99, javax.swing.GroupLayout.PREFERRED_SIZE))
                            .addComponent(jLabel6))
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, false)
                            .addComponent(Enter, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                            .addComponent(RunButton, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)))
                    .addGroup(layout.createSequentialGroup()
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addComponent(jComboBox1, javax.swing.GroupLayout.PREFERRED_SIZE, 142, javax.swing.GroupLayout.PREFERRED_SIZE)
                            .addComponent(jLabel4))
                        .addGap(12, 12, 12)
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, false)
                            .addComponent(jScrollPane2, javax.swing.GroupLayout.PREFERRED_SIZE, 280, javax.swing.GroupLayout.PREFERRED_SIZE)
                            .addGroup(layout.createSequentialGroup()
                                .addComponent(jLabel2)
                                .addGap(78, 78, 78)
                                .addComponent(jLabel3)
                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                                .addComponent(jLabel5)
                                .addGap(12, 12, 12)))))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(jScrollPane1)
                    .addGroup(layout.createSequentialGroup()
                        .addComponent(jLabel7)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(jScrollPane3, javax.swing.GroupLayout.PREFERRED_SIZE, 218, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addComponent(simulationSpeed, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                            .addGroup(layout.createSequentialGroup()
                                .addGap(24, 24, 24)
                                .addComponent(jLabel9)))
                        .addGap(0, 0, Short.MAX_VALUE)))
                .addContainerGap())
            .addGroup(layout.createSequentialGroup()
                .addGap(50, 50, 50)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(jScrollPane5, javax.swing.GroupLayout.PREFERRED_SIZE, 1023, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addGroup(layout.createSequentialGroup()
                        .addGap(10, 10, 10)
                        .addComponent(jLabel8)))
                .addContainerGap(45, Short.MAX_VALUE))
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addGap(11, 11, 11)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(jLabel4)
                    .addComponent(jLabel2)
                    .addComponent(jLabel3)
                    .addComponent(jLabel5))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(jComboBox1, javax.swing.GroupLayout.PREFERRED_SIZE, 37, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(jScrollPane2, javax.swing.GroupLayout.PREFERRED_SIZE, 226, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addGroup(layout.createSequentialGroup()
                        .addComponent(jScrollPane1, javax.swing.GroupLayout.PREFERRED_SIZE, 155, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addGap(13, 13, 13)
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addGroup(layout.createSequentialGroup()
                                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                                    .addGroup(layout.createSequentialGroup()
                                        .addGap(17, 17, 17)
                                        .addComponent(jLabel7))
                                    .addGroup(layout.createSequentialGroup()
                                        .addComponent(jLabel9)
                                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                                        .addComponent(simulationSpeed, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)))
                                .addGap(0, 0, Short.MAX_VALUE))
                            .addComponent(jScrollPane3, javax.swing.GroupLayout.PREFERRED_SIZE, 0, Short.MAX_VALUE))))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(jLabel1)
                    .addComponent(UserInput, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(Enter))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(jLabel6)
                    .addComponent(RunButton))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(jLabel8)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(jScrollPane5, javax.swing.GroupLayout.PREFERRED_SIZE, 90, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addGap(30, 30, 30))
        );

        pack();
    }// </editor-fold>//GEN-END:initComponents

    private void jComboBox1ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jComboBox1ActionPerformed
        String selected = ((String) jComboBox1.getSelectedItem()).trim();

    String algorithmKey = switch (selected) {
        case "First-In First-Out (FIFO/FCFS)" -> "FIFO";
        case "Shortest Job First (SJF) Non-Preemptive" -> "SJF";
        case "Shortest Remaining Time First (SRTF) Preemptive" -> "SRTF";
        case "Round Robin (RR)" -> "RR";
        case "Multilevel Feedback Queue (MLFQ)" -> "MLFQ";
        default -> "UNKNOWN";
    };

    if (!algorithmKey.equals(selectedAlgorithm)) {
        selectedAlgorithm = algorithmKey;
        processList.clear();

        // Clear progress bars
        processPanel.removeAll();
        processPanel.revalidate();
        processPanel.repaint();

        // Clear table
        ((javax.swing.table.DefaultTableModel) jTable1.getModel()).setRowCount(0);

        // Clear queue panel
        queuePanel.removeAll();
        queuePanel.revalidate();
        queuePanel.repaint();

        // Clear Gantt chart
        ganttPanel.removeAll();
        ganttPanel.revalidate();
        ganttPanel.repaint();

        UserInput.setText("");
        RunButton.setSelected(false);
        JOptionPane.showMessageDialog(this, "Switched to: " + selected + ". Enter new process info.");
    }
        
    }//GEN-LAST:event_jComboBox1ActionPerformed

    private void EnterActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_EnterActionPerformed
        // TODO add your handling code here:
    processPanel.removeAll();  // Clear UI
    processList = new ArrayList<>(); // Reset data list

    int numProcesses;
    try {
        numProcesses = Integer.parseInt(UserInput.getText());
        if (numProcesses < 1 || numProcesses > 20) {
            throw new NumberFormatException();
        }
    } catch (NumberFormatException ex) {
        JOptionPane.showMessageDialog(this, "Enter a valid number between 1 and 20.");
        return;
    }

    for (int i = 1; i <= numProcesses; i++) {
        try {
            String arrivalStr = JOptionPane.showInputDialog("Enter Arrival Time for P" + i + ":");
            if (arrivalStr == null) {
                JOptionPane.showMessageDialog(this, "Input cancelled. Returning to main screen.");
                return; // exit the method gracefully
            }

            int arrival = Integer.parseInt(arrivalStr);

            String burstStr = JOptionPane.showInputDialog("Enter Burst Time for P" + i + ":");
            if (burstStr == null) {
                JOptionPane.showMessageDialog(this, "Input cancelled. Returning to main screen.");
                return;
            }

            int burst = Integer.parseInt(burstStr);

            // Create and store process
            Process p = new Process(i, arrival, burst);

            // Create corresponding row in UI
            JPanel row = new JPanel(new BorderLayout(5, 5));
            JLabel pidLabel = new JLabel("P" + i);
            JProgressBar progressBar = new JProgressBar();
            progressBar.setStringPainted(true);
            progressBar.setValue(0);
            JLabel stateLabel = new JLabel("Ready");

            // Attach components to process
            p.progressBar = progressBar;
            p.stateLabel = stateLabel;

            // Add to list and panel
            processList.add(p);
            row.add(pidLabel, BorderLayout.WEST);
            row.add(progressBar, BorderLayout.CENTER);
            row.add(stateLabel, BorderLayout.EAST);
            stateLabel.setBorder(javax.swing.BorderFactory.createEmptyBorder(0, 0, 0, 15));

            processPanel.add(row);
        } catch (NumberFormatException e) {
            JOptionPane.showMessageDialog(this, "Invalid input. Please enter numeric values.");
            i--; // Retry this process
        }
    }

    processPanel.revalidate();
    processPanel.repaint();
    }//GEN-LAST:event_EnterActionPerformed

    private void UserInputActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_UserInputActionPerformed
        // TODO add your handling code here:
       
    }//GEN-LAST:event_UserInputActionPerformed

    private void RunButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_RunButtonActionPerformed
         if (processList == null || processList.isEmpty()) {
        JOptionPane.showMessageDialog(this, "Please enter processes first.");
        return;
    }

    // Disable input during run
    Enter.setEnabled(false);
    UserInput.setEnabled(false);
    RunButton.setEnabled(false);

    // Run selected algorithm
    switch (selectedAlgorithm) {
        case "FIFO":
            runFIFO();
            break;
        case "SJF":
            runSJF();
            break;
        case "SRTF":
            runSRTF();
            break;
        case "RR":
        case "MLFQ":
            JOptionPane.showMessageDialog(this, selectedAlgorithm + " not implemented yet.");
            Enter.setEnabled(true);
            UserInput.setEnabled(true);
            RunButton.setEnabled(true);
            break;
        default:
            JOptionPane.showMessageDialog(this, "Unknown algorithm selected.");
            Enter.setEnabled(true);
            UserInput.setEnabled(true);
            RunButton.setEnabled(true);
         } 
    }//GEN-LAST:event_RunButtonActionPerformed

    private void runFIFO() {
    // Sort by arrival time
 processList.sort((p1, p2) -> Integer.compare(p1.arrivalTime, p2.arrivalTime));

    // Clear Gantt chart and update queue before simulation
    SwingUtilities.invokeLater(() -> {
        updateQueueDisplay(processList);
        ganttPanel.removeAll();
        ganttPanel.revalidate();
        ganttPanel.repaint();
    });

    new Thread(() -> {
        int[] currentTime = {0};  // mutable for lambda use
        int[] totalTAT = {0};
        int[] totalRT = {0};

        for (int i = 0; i < processList.size(); i++) {
            Process p = processList.get(i);

            // Simulate idle time (if CPU is waiting for process to arrive)
            if (currentTime[0] < p.arrivalTime) {
                try {
                    Thread.sleep((p.arrivalTime - currentTime[0]) * simulationDelay);
                } catch (InterruptedException e) {}
                currentTime[0] = p.arrivalTime;
            }

            // Update the remaining queue display
            int finalI = i;
            SwingUtilities.invokeLater(() -> {
                List<Process> remainingQueue = processList.subList(finalI, processList.size());
                updateQueueDisplay(remainingQueue);
            });

            int finalIndex = i;
            int startTime = currentTime[0];
            int burst = p.burstTime;

            SwingWorker<Void, Integer> worker = new SwingWorker<>() {
                @Override
                protected Void doInBackground() throws Exception {
                    p.stateLabel.setText("Running");
                    for (int t = 1; t <= burst; t++) {
                        Thread.sleep(simulationDelay); // ⏳ dynamic delay
                        publish(t * 100 / burst); // update progress
                    }
                    publish(100);
                    return null;
                }

                @Override
                protected void process(List<Integer> chunks) {
                    int value = chunks.get(chunks.size() - 1);
                    p.progressBar.setValue(value);
                }

                @Override
                protected void done() {
                     SwingUtilities.invokeLater(() -> {
                        p.progressBar.setValue(100);
                        p.stateLabel.setText("Done");

                        currentTime[0] = startTime + burst;
                        p.responseTime = startTime - p.arrivalTime;
                        p.completionTime = currentTime[0];
                        p.turnaroundTime = p.completionTime - p.arrivalTime;

                        totalRT[0] += p.responseTime;
                        totalTAT[0] += p.turnaroundTime;

                        // ✅ Gantt update immediately
                        updateGanttChart(startTime, currentTime[0], p.pid);

                        // Update remaining queue
                        if (finalIndex + 1 < processList.size()) {
                            updateQueueDisplay(processList.subList(finalIndex + 1, processList.size()));
                        } else {
                            updateQueueDisplay(new ArrayList<>());
                        }

                        // Enable UI after final process
                        if (finalIndex == processList.size() - 1) {
                            updateTable(totalTAT[0], totalRT[0]);
                            Enter.setEnabled(true);
                            UserInput.setEnabled(true);
                            RunButton.setEnabled(true);
                            RunButton.setSelected(false);
                        }
                    });
                }
            };

            worker.execute();

            try {
                // Wait for process to complete before next
                while (!worker.isDone()) {
                    Thread.sleep(simulationDelay); // ⏳ dynamic check delay
                }
            } catch (InterruptedException e) {}
        }
    }).start();
}
    
    private void runSJF() {
      new Thread(() -> {
        List<Process> readyQueue = new ArrayList<>();
        int time = 0;
        int completed = 0;
        int n = processList.size();
        int[] totalRT = {0};
        int[] totalTAT = {0};

        // Initialize all processes
        for (Process p : processList) {
            p.remainingTime = p.burstTime;
            p.started = false;
        }

        // Sort by arrival time then burst time
        processList.sort((p1, p2) -> {
            if (p1.arrivalTime != p2.arrivalTime) {
                return Integer.compare(p1.arrivalTime, p2.arrivalTime);
            }
            return Integer.compare(p1.burstTime, p2.burstTime);
        });

        // Clear Gantt chart before start
        SwingUtilities.invokeLater(() -> {
            ganttPanel.removeAll();
            ganttPanel.revalidate();
            ganttPanel.repaint();
        });

        while (completed < n) {
            // Fill ready queue
            readyQueue.clear();
            for (Process p : processList) {
                if (!p.started && p.arrivalTime <= time) {
                    readyQueue.add(p);
                }
            }

            // Update queue display
            List<Process> displayQueue = new ArrayList<>(readyQueue);
            SwingUtilities.invokeLater(() -> updateQueueDisplay(displayQueue));

            // No ready processes, idle
            if (readyQueue.isEmpty()) {
                time++;
                try {
                    Thread.sleep(simulationDelay); // ⏳ idle wait
                } catch (InterruptedException ignored) {}
                continue;
            }

            // Select shortest job
            readyQueue.sort((p1, p2) -> Integer.compare(p1.burstTime, p2.burstTime));
            Process current = readyQueue.get(0);
            current.started = true;

            int start = time;
            int end = time + current.burstTime;

            // Record response & turnaround
            current.responseTime = start - current.arrivalTime;
            current.completionTime = end;
            current.turnaroundTime = end - current.arrivalTime;
            totalRT[0] += current.responseTime;
            totalTAT[0] += current.turnaroundTime;

            Process finalCurrent = current;
            SwingUtilities.invokeLater(() -> finalCurrent.stateLabel.setText("Running"));

            // Simulate execution
            for (int t = 0; t < current.burstTime; t++) {
                try {
                    Thread.sleep(simulationDelay); // ⏳ dynamic speed
                } catch (InterruptedException ignored) {}

                int progress = (int) (((t + 1) / (float) current.burstTime) * 100);
                SwingUtilities.invokeLater(() -> finalCurrent.progressBar.setValue(progress));

                int finalTime = time + t + 1;

                // Refresh queue at each tick
                List<Process> tickQueue = new ArrayList<>();
                for (Process p : processList) {
                    if (!p.started && p.arrivalTime <= finalTime) {
                        tickQueue.add(p);
                    }
                }
                SwingUtilities.invokeLater(() -> updateQueueDisplay(tickQueue));
            }

            // Final UI update after process finishes
            SwingUtilities.invokeLater(() -> {
                finalCurrent.stateLabel.setText("Done");
                finalCurrent.progressBar.setValue(100);
                updateGanttChart(start, end, finalCurrent.pid);
            });

            time = end;
            completed++;
        }

        // All done — update table
        SwingUtilities.invokeLater(() -> {
            updateTable(totalTAT[0], totalRT[0]);
            Enter.setEnabled(true);
            UserInput.setEnabled(true);
            RunButton.setEnabled(true);
            RunButton.setSelected(false);
        });
    }).start();
}

    
    private void runSRTF() {
     new Thread(() -> {
        List<Process> readyQueue = new ArrayList<>();
        int time = 0;
        int completed = 0;
        int n = processList.size();
        int[] totalRT = {0};
        int[] totalTAT = {0};

        for (Process p : processList) {
            p.remainingTime = p.burstTime;
            p.started = false;
        }

        SwingUtilities.invokeLater(() -> {
            ganttPanel.removeAll();
            ganttPanel.revalidate();
            ganttPanel.repaint();
        });

        Process current = null;
        int start = -1;

        while (completed < n) {
            for (Process p : processList) {
                if (p.arrivalTime == time) {
                    readyQueue.add(p);
                }
            }

            Process shortest = null;
            for (Process p : readyQueue) {
                if (p.remainingTime > 0) {
                    if (shortest == null || p.remainingTime < shortest.remainingTime) {
                        shortest = p;
                    }
                }
            }

            if (shortest != null) {
                if (current != shortest) {
                    if (current != null && current.remainingTime > 0) {
                        Process finalOld = current;
                        SwingUtilities.invokeLater(() -> finalOld.stateLabel.setText("Ready"));
                    }

                    current = shortest;
                    start = time;

                    if (!current.started) {
                        current.started = true;
                        current.responseTime = time - current.arrivalTime;
                    }

                    Process finalCurrentStart = current;
                    SwingUtilities.invokeLater(() -> finalCurrentStart.stateLabel.setText("Running"));
                }

                Process finalCurrentTick = current;
                SwingUtilities.invokeLater(() -> {
                    finalCurrentTick.progressBar.setValue(
                        (int)(((finalCurrentTick.burstTime - finalCurrentTick.remainingTime + 1) * 100.0) / finalCurrentTick.burstTime)
                    );
                });

                current.remainingTime--;

                if (current.remainingTime == 0) {
                    // Final update occurs after current tick
                    Process finalCurrentDone = current;
                    int finalStart = start;
                    int finalEnd = time + 1;

                    current.completionTime = finalEnd;
                    current.turnaroundTime = finalCurrentDone.completionTime - finalCurrentDone.arrivalTime;
                    totalRT[0] += finalCurrentDone.responseTime;
                    totalTAT[0] += finalCurrentDone.turnaroundTime;

                    SwingUtilities.invokeLater(() -> {
                        finalCurrentDone.stateLabel.setText("Done");
                        finalCurrentDone.progressBar.setValue(100);
                        updateGanttChart(finalStart, finalEnd, finalCurrentDone.pid);
                    });

                    current = null;
                    completed++;
                }
            }

            List<Process> displayQueue = new ArrayList<>();
            for (Process p : readyQueue) {
                if (p.remainingTime > 0 && p != current) {
                    displayQueue.add(p);
                }
            }

            List<Process> finalQueue = new ArrayList<>(displayQueue);
            SwingUtilities.invokeLater(() -> updateQueueDisplay(finalQueue));

            try {
                Thread.sleep(simulationDelay); // ✅ delay tied to slider
            } catch (InterruptedException ignored) {}

            time++;
        }

        SwingUtilities.invokeLater(() -> {
            updateTable(totalTAT[0], totalRT[0]);
            Enter.setEnabled(true);
            UserInput.setEnabled(true);
            RunButton.setEnabled(true);
            RunButton.setSelected(false);
        });
    }).start();
}

    
    private void updateTable(int totalTAT, int totalRT) {
    javax.swing.table.DefaultTableModel model = (javax.swing.table.DefaultTableModel) jTable1.getModel();
    model.setRowCount(0);

    for (Process p : processList) {
        model.addRow(new Object[] {
            "P" + p.pid, p.arrivalTime, p.burstTime, p.completionTime,
            p.turnaroundTime, p.responseTime, "", ""
        });
    }

    float avgTAT = (float) totalTAT / processList.size();
    float avgRT = (float) totalRT / processList.size();

    model.addRow(new Object[] {
        "", "", "", "", "", "", String.format("%.2f", avgTAT), String.format("%.2f", avgRT)
    });
}
    
    private void updateQueueDisplay(List<Process> queue) {
    queuePanel.removeAll();
    for (Process p : queue) {
        JLabel label = new JLabel("P" + p.pid);
        label.setBorder(javax.swing.BorderFactory.createLineBorder(java.awt.Color.BLACK));
        label.setHorizontalAlignment(JLabel.CENTER);
        label.setOpaque(true);
        label.setBackground(java.awt.Color.LIGHT_GRAY);
        queuePanel.add(label);
    }
    queuePanel.revalidate();
    queuePanel.repaint();
}
    
    private void updateGanttChart(int startTime, int endTime, int pid) {
    JPanel block = new JPanel();
    block.setBorder(BorderFactory.createLineBorder(Color.BLACK));
    block.setBackground(Color.YELLOW);
    block.setLayout(new BoxLayout(block, BoxLayout.Y_AXIS)); // vertical layout

    // PID Label
    JLabel pidLabel = new JLabel("P" + pid);
    pidLabel.setFont(new Font("Arial", Font.BOLD, 14));
    pidLabel.setAlignmentX(Component.CENTER_ALIGNMENT);
    pidLabel.setHorizontalAlignment(SwingConstants.CENTER);

    // Time Label
    JLabel timeLabel = new JLabel("Running...");
    timeLabel.setFont(new Font("Arial", Font.PLAIN, 12));
    timeLabel.setAlignmentX(Component.CENTER_ALIGNMENT);
    timeLabel.setHorizontalAlignment(SwingConstants.CENTER);

    block.add(Box.createVerticalGlue()); // spacing above
    block.add(pidLabel);
    block.add(timeLabel);
    block.add(Box.createVerticalGlue()); // spacing below

    int blockWidth = Math.max((endTime - startTime) * 30, 50);
    block.setPreferredSize(new Dimension(blockWidth, ganttPanel.getHeight())); // 👈 full height of panel

    SwingUtilities.invokeLater(() -> {
        ganttPanel.add(block);
        ganttPanel.revalidate();
        ganttPanel.repaint();
    });

    // After execution, change color + show time range
    new Thread(() -> {
        try {
            Thread.sleep((endTime - startTime) * 500);
        } catch (InterruptedException ignored) {}

        SwingUtilities.invokeLater(() -> {
            block.setBackground(Color.CYAN);
            timeLabel.setText(startTime + " - " + endTime);
        });
    }).start();

    // Resize Gantt Panel width if needed
    SwingUtilities.invokeLater(() -> {
        int totalBlocks = ganttPanel.getComponentCount();
        int totalWidth = totalBlocks * (blockWidth + 5); // 5 = spacing
        ganttPanel.setPreferredSize(new Dimension(totalWidth, ganttPanel.getHeight()));
        ganttPanel.revalidate();
        ganttPanel.repaint();
    });
}



    /**
     * @param args the command line arguments
     */
    public static void main(String args[]) {
        /* Set the Nimbus look and feel */
        //<editor-fold defaultstate="collapsed" desc=" Look and feel setting code (optional) ">
        /* If Nimbus (introduced in Java SE 6) is not available, stay with the default look and feel.
         * For details see http://download.oracle.com/javase/tutorial/uiswing/lookandfeel/plaf.html 
         */
        try {
            for (javax.swing.UIManager.LookAndFeelInfo info : javax.swing.UIManager.getInstalledLookAndFeels()) {
                if ("Nimbus".equals(info.getName())) {
                    javax.swing.UIManager.setLookAndFeel(info.getClassName());
                    break;
                }
            }
        } catch (ClassNotFoundException ex) {
            java.util.logging.Logger.getLogger(NewJFrame.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (InstantiationException ex) {
            java.util.logging.Logger.getLogger(NewJFrame.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (IllegalAccessException ex) {
            java.util.logging.Logger.getLogger(NewJFrame.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (javax.swing.UnsupportedLookAndFeelException ex) {
            java.util.logging.Logger.getLogger(NewJFrame.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        }
        //</editor-fold>

        /* Create and display the form */
        java.awt.EventQueue.invokeLater(new Runnable() {
            public void run() {
                new NewJFrame().setVisible(true);
            }
        });
    }

    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JButton Enter;
    private javax.swing.JToggleButton RunButton;
    private javax.swing.JTextField UserInput;
    private javax.swing.JPanel ganttPanel;
    private javax.swing.JComboBox<String> jComboBox1;
    private javax.swing.JLabel jLabel1;
    private javax.swing.JLabel jLabel2;
    private javax.swing.JLabel jLabel3;
    private javax.swing.JLabel jLabel4;
    private javax.swing.JLabel jLabel5;
    private javax.swing.JLabel jLabel6;
    private javax.swing.JLabel jLabel7;
    private javax.swing.JLabel jLabel8;
    private javax.swing.JLabel jLabel9;
    private javax.swing.JScrollPane jScrollPane1;
    private javax.swing.JScrollPane jScrollPane2;
    private javax.swing.JScrollPane jScrollPane3;
    private javax.swing.JScrollPane jScrollPane5;
    private javax.swing.JTable jTable1;
    private javax.swing.JPanel processPanel;
    private javax.swing.JPanel queuePanel;
    private javax.swing.JSlider simulationSpeed;
    // End of variables declaration//GEN-END:variables
}
