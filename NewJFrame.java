/*
 * Click nbfs://nbhost/SystemFileSystem/Templates/Licenses/license-default.txt to change this license
 * Click nbfs://nbhost/SystemFileSystem/Templates/GUIForms/JFrame.java to edit this template
 */

/**
 *
 * @author johncalen.nombrado
 */

import javax.swing.JButton;
import javax.swing.JFrame;
import javax.swing.JLabel;
import javax.swing.JOptionPane;
import javax.swing.JPanel;
import javax.swing.JTextField;
import javax.swing.JProgressBar;
import javax.swing.JScrollPane;
import javax.swing.BoxLayout;
import javax.swing.SwingUtilities;
import java.awt.BorderLayout;
import java.awt.Color;
import java.awt.Component;
import java.awt.Dimension;
import java.awt.FlowLayout;
import java.awt.Font;
import java.awt.GridLayout;
import java.awt.KeyboardFocusManager;
import java.util.List;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.awt.event.KeyEvent;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.HashSet;
import java.util.LinkedList;
import java.util.Map;
import java.util.Queue;
import java.util.Set;
import javax.swing.BorderFactory;
import javax.swing.Box;
import javax.swing.JScrollBar;
import javax.swing.SwingConstants;
import javax.swing.SwingWorker;

public class NewJFrame extends javax.swing.JFrame {

    /**
     * Creates new form NewJFrame
     * 
     */
   
    private List<Process> processList = new ArrayList<>();
    private String selectedAlgorithm = "FIFO"; // Default
    private volatile int simulationDelay = 500;  // default value

    public NewJFrame() {
    initComponents();
    setResizable(false);
    
    
    
    jComboBox1.setFocusable(false);

    // 🧱 (Optional) Additional protection: Block ALL key events when ComboBox is focused
    KeyboardFocusManager.getCurrentKeyboardFocusManager().addKeyEventDispatcher(e -> {
        if (jComboBox1.isFocusOwner() &&
            (e.getID() == KeyEvent.KEY_PRESSED || e.getID() == KeyEvent.KEY_TYPED || e.getID() == KeyEvent.KEY_RELEASED)) {
            e.consume();  // Stop the event from being processed
            return true;
        }
        return false;
    });

    // 🆕 Simulation speed slider setup
    simulationSpeed.setMinimum(10);
    simulationSpeed.setMaximum(1000);
    simulationSpeed.setValue(500); // default speed: 500 ms
    simulationSpeed.setMajorTickSpacing(250);
    simulationSpeed.setMinorTickSpacing(50);
    simulationSpeed.setPaintTicks(true);
    simulationSpeed.setPaintLabels(true);

    simulationSpeed.addChangeListener(e -> {
        simulationDelay = simulationSpeed.getValue();
    });

    // Existing setup
    jComboBox1.setModel(new javax.swing.DefaultComboBoxModel<>(new String[] {
        "First-In First-Out (FIFO/FCFS)",
        "Shortest Job First (SJF) Non-Preemptive",
        "Shortest Remaining Time First (SRTF) Preemptive",
        "Round Robin (RR)",
        "Multilevel Feedback Queue (MLFQ)"
    }));

     processPanel.setLayout(new GridLayout(0, 1, 5, 5));
     queuePanel.setLayout(new FlowLayout(FlowLayout.LEFT));

     ganttPanel.setLayout(new BoxLayout(ganttPanel, BoxLayout.X_AXIS));
     jScrollPane5.setViewportView(ganttPanel);
    }
    
    

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        jComboBox1 = new javax.swing.JComboBox<>();
        AlgorithmLabel = new javax.swing.JLabel();
        jScrollPane1 = new javax.swing.JScrollPane();
        jTable1 = new javax.swing.JTable();
        Enter = new javax.swing.JButton();
        UserInput = new javax.swing.JTextField();
        HowManyProcessLabel = new javax.swing.JLabel();
        jScrollPane2 = new javax.swing.JScrollPane();
        processPanel = new javax.swing.JPanel();
        PIDLabel = new javax.swing.JLabel();
        ProgressLabel = new javax.swing.JLabel();
        StateLabel = new javax.swing.JLabel();
        RunButton = new javax.swing.JToggleButton();
        jLabel6 = new javax.swing.JLabel();
        QueueLabel = new javax.swing.JLabel();
        jScrollPane3 = new javax.swing.JScrollPane();
        queuePanel = new javax.swing.JPanel();
        jScrollPane5 = new javax.swing.JScrollPane();
        ganttPanel = new javax.swing.JPanel();
        simulationSpeed = new javax.swing.JSlider();
        SimulationSpeedLabel = new javax.swing.JLabel();
        resetButton = new javax.swing.JButton();
        jScrollPane4 = new javax.swing.JScrollPane();
        actionLog = new javax.swing.JTextArea();
        jLabel1 = new javax.swing.JLabel();
        jLabel2 = new javax.swing.JLabel();
        jLabel3 = new javax.swing.JLabel();

        setDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE);

        jComboBox1.setModel(new javax.swing.DefaultComboBoxModel<>(new String[] { "First-In First-Out (FIFO/FCFS) ", "Shortest Job First (SJF) Non-Preemptive", "Shortest Remaining Time First (SRTF) Preemptive", "Round Robin (RR)", "Multilevel Feedback Queue (MLFQ)" }));
        jComboBox1.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jComboBox1ActionPerformed(evt);
            }
        });

        AlgorithmLabel.setFont(new java.awt.Font("Helvetica Neue", 1, 12)); // NOI18N
        AlgorithmLabel.setText("ALGORITHMS");

        jTable1.setBorder(javax.swing.BorderFactory.createLineBorder(new java.awt.Color(0, 0, 0)));
        jTable1.setModel(new javax.swing.table.DefaultTableModel(
            new Object [][] {
                {null, null, null, null, null, null, null, null},
                {null, null, null, null, null, null, null, null},
                {null, null, null, null, null, null, null, null},
                {null, null, null, null, null, null, null, null},
                {null, null, null, null, null, null, null, null},
                {null, null, null, null, null, null, null, null},
                {null, null, null, null, null, null, null, null},
                {null, null, null, null, null, null, null, null},
                {null, null, null, null, null, null, null, null},
                {null, null, null, null, null, null, null, null}
            },
            new String [] {
                "Process ID:", "Arrival Time", "Burst Time", "Completion Time", "Turnaround Time", "Response Time", "Average Turnaround Time", "Average Response Time"
            }
        ) {
            boolean[] canEdit = new boolean [] {
                false, false, false, false, false, false, false, false
            };

            public boolean isCellEditable(int rowIndex, int columnIndex) {
                return canEdit [columnIndex];
            }
        });
        jScrollPane1.setViewportView(jTable1);

        Enter.setText("Enter");
        Enter.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                EnterActionPerformed(evt);
            }
        });

        UserInput.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                UserInputActionPerformed(evt);
            }
        });

        HowManyProcessLabel.setFont(new java.awt.Font("Helvetica Neue", 1, 11)); // NOI18N
        HowManyProcessLabel.setText("How many process?");

        processPanel.setBackground(new java.awt.Color(255, 255, 255));
        processPanel.setBorder(new javax.swing.border.MatteBorder(null));

        javax.swing.GroupLayout processPanelLayout = new javax.swing.GroupLayout(processPanel);
        processPanel.setLayout(processPanelLayout);
        processPanelLayout.setHorizontalGroup(
            processPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 276, Short.MAX_VALUE)
        );
        processPanelLayout.setVerticalGroup(
            processPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 347, Short.MAX_VALUE)
        );

        jScrollPane2.setViewportView(processPanel);

        PIDLabel.setFont(new java.awt.Font("Helvetica Neue", 1, 12)); // NOI18N
        PIDLabel.setText("PID");

        ProgressLabel.setFont(new java.awt.Font("Helvetica Neue", 1, 12)); // NOI18N
        ProgressLabel.setText("Progress");

        StateLabel.setFont(new java.awt.Font("Helvetica Neue", 1, 12)); // NOI18N
        StateLabel.setText("State");

        RunButton.setText("Run");
        RunButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                RunButtonActionPerformed(evt);
            }
        });

        jLabel6.setFont(new java.awt.Font("Helvetica Neue", 1, 13)); // NOI18N

        QueueLabel.setFont(new java.awt.Font("Helvetica Neue", 1, 18)); // NOI18N
        QueueLabel.setText("Queue:");

        jScrollPane3.setBorder(javax.swing.BorderFactory.createBevelBorder(javax.swing.border.BevelBorder.RAISED));

        queuePanel.setBackground(new java.awt.Color(255, 255, 255));
        queuePanel.setBorder(javax.swing.BorderFactory.createEtchedBorder());

        javax.swing.GroupLayout queuePanelLayout = new javax.swing.GroupLayout(queuePanel);
        queuePanel.setLayout(queuePanelLayout);
        queuePanelLayout.setHorizontalGroup(
            queuePanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 216, Short.MAX_VALUE)
        );
        queuePanelLayout.setVerticalGroup(
            queuePanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 120, Short.MAX_VALUE)
        );

        jScrollPane3.setViewportView(queuePanel);

        jScrollPane5.setBackground(new java.awt.Color(255, 255, 255));
        jScrollPane5.setBorder(javax.swing.BorderFactory.createBevelBorder(javax.swing.border.BevelBorder.RAISED));

        ganttPanel.setBackground(new java.awt.Color(255, 255, 255));
        ganttPanel.setBorder(javax.swing.BorderFactory.createEtchedBorder());

        javax.swing.GroupLayout ganttPanelLayout = new javax.swing.GroupLayout(ganttPanel);
        ganttPanel.setLayout(ganttPanelLayout);
        ganttPanelLayout.setHorizontalGroup(
            ganttPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 1082, Short.MAX_VALUE)
        );
        ganttPanelLayout.setVerticalGroup(
            ganttPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 100, Short.MAX_VALUE)
        );

        jScrollPane5.setViewportView(ganttPanel);

        SimulationSpeedLabel.setFont(new java.awt.Font("Helvetica Neue", 1, 18)); // NOI18N
        SimulationSpeedLabel.setText("Simulation Speed");

        resetButton.setText("Reset All");
        resetButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                resetButtonActionPerformed(evt);
            }
        });

        actionLog.setEditable(false);
        actionLog.setColumns(50);
        actionLog.setLineWrap(true);
        actionLog.setRows(8);
        actionLog.setWrapStyleWord(true);
        actionLog.setBorder(javax.swing.BorderFactory.createLineBorder(new java.awt.Color(0, 0, 0)));
        jScrollPane4.setViewportView(actionLog);

        jLabel1.setFont(new java.awt.Font("Segoe UI", 1, 14)); // NOI18N
        jLabel1.setText("Action Message");

        jLabel2.setFont(new java.awt.Font("Segoe UI", 1, 18)); // NOI18N
        jLabel2.setText("Gnatt Chart ");

        jLabel3.setFont(new java.awt.Font("Segoe UI", 1, 12)); // NOI18N
        jLabel3.setText("execution timeline of each process :");

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addGap(17, 17, 17)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(layout.createSequentialGroup()
                        .addGap(5, 5, 5)
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING)
                            .addGroup(layout.createSequentialGroup()
                                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                                    .addComponent(jComboBox1, javax.swing.GroupLayout.PREFERRED_SIZE, 142, javax.swing.GroupLayout.PREFERRED_SIZE)
                                    .addComponent(AlgorithmLabel))
                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, false)
                                    .addComponent(jScrollPane2, javax.swing.GroupLayout.PREFERRED_SIZE, 280, javax.swing.GroupLayout.PREFERRED_SIZE)
                                    .addGroup(layout.createSequentialGroup()
                                        .addComponent(PIDLabel)
                                        .addGap(78, 78, 78)
                                        .addComponent(ProgressLabel)
                                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                                        .addComponent(StateLabel)
                                        .addGap(12, 12, 12))))
                            .addGroup(layout.createSequentialGroup()
                                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING)
                                    .addGroup(layout.createSequentialGroup()
                                        .addComponent(jLabel6)
                                        .addGap(224, 224, 224))
                                    .addGroup(layout.createSequentialGroup()
                                        .addComponent(HowManyProcessLabel)
                                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                                        .addComponent(UserInput, javax.swing.GroupLayout.PREFERRED_SIZE, 99, javax.swing.GroupLayout.PREFERRED_SIZE)
                                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                                        .addComponent(Enter)))
                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, false)
                                    .addComponent(resetButton, javax.swing.GroupLayout.Alignment.TRAILING, javax.swing.GroupLayout.PREFERRED_SIZE, 0, Short.MAX_VALUE)
                                    .addComponent(RunButton, javax.swing.GroupLayout.Alignment.TRAILING, javax.swing.GroupLayout.DEFAULT_SIZE, 72, Short.MAX_VALUE))))
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addComponent(jScrollPane1)
                            .addGroup(layout.createSequentialGroup()
                                .addComponent(QueueLabel)
                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                                    .addComponent(jScrollPane4, javax.swing.GroupLayout.PREFERRED_SIZE, 256, javax.swing.GroupLayout.PREFERRED_SIZE)
                                    .addGroup(layout.createSequentialGroup()
                                        .addComponent(jScrollPane3, javax.swing.GroupLayout.PREFERRED_SIZE, 218, javax.swing.GroupLayout.PREFERRED_SIZE)
                                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                                            .addComponent(simulationSpeed, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                                            .addGroup(layout.createSequentialGroup()
                                                .addGap(24, 24, 24)
                                                .addComponent(SimulationSpeedLabel))))
                                    .addComponent(jLabel1, javax.swing.GroupLayout.PREFERRED_SIZE, 200, javax.swing.GroupLayout.PREFERRED_SIZE))
                                .addGap(0, 0, Short.MAX_VALUE))))
                    .addGroup(layout.createSequentialGroup()
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addGroup(layout.createSequentialGroup()
                                .addComponent(jLabel2)
                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                                .addComponent(jLabel3))
                            .addComponent(jScrollPane5, javax.swing.GroupLayout.PREFERRED_SIZE, 1020, javax.swing.GroupLayout.PREFERRED_SIZE))
                        .addGap(0, 80, Short.MAX_VALUE)))
                .addContainerGap())
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addGap(11, 11, 11)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(AlgorithmLabel)
                    .addComponent(PIDLabel)
                    .addComponent(ProgressLabel)
                    .addComponent(StateLabel))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(layout.createSequentialGroup()
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addComponent(jComboBox1, javax.swing.GroupLayout.PREFERRED_SIZE, 37, javax.swing.GroupLayout.PREFERRED_SIZE)
                            .addComponent(jScrollPane2, javax.swing.GroupLayout.PREFERRED_SIZE, 226, javax.swing.GroupLayout.PREFERRED_SIZE))
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                            .addComponent(HowManyProcessLabel)
                            .addComponent(UserInput, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                            .addComponent(Enter)
                            .addComponent(RunButton))
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(resetButton)
                        .addGap(0, 0, 0)
                        .addComponent(jLabel6)
                        .addGap(86, 86, 86))
                    .addGroup(layout.createSequentialGroup()
                        .addComponent(jScrollPane1, javax.swing.GroupLayout.PREFERRED_SIZE, 155, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addGap(5, 5, 5)
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addGroup(layout.createSequentialGroup()
                                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                                    .addGroup(layout.createSequentialGroup()
                                        .addGap(17, 17, 17)
                                        .addComponent(QueueLabel))
                                    .addGroup(layout.createSequentialGroup()
                                        .addComponent(SimulationSpeedLabel)
                                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                                        .addComponent(simulationSpeed, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)))
                                .addGap(0, 0, Short.MAX_VALUE))
                            .addComponent(jScrollPane3, javax.swing.GroupLayout.PREFERRED_SIZE, 0, Short.MAX_VALUE))
                        .addGap(42, 42, 42)
                        .addComponent(jLabel1)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(jScrollPane4, javax.swing.GroupLayout.PREFERRED_SIZE, 90, javax.swing.GroupLayout.PREFERRED_SIZE)))
                .addGap(1, 1, 1)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(jLabel2)
                    .addComponent(jLabel3))
                .addGap(1, 1, 1)
                .addComponent(jScrollPane5, javax.swing.GroupLayout.PREFERRED_SIZE, 90, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addGap(18, 18, 18))
        );

        pack();
    }// </editor-fold>//GEN-END:initComponents

    private void jComboBox1ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jComboBox1ActionPerformed
        String selected = ((String) jComboBox1.getSelectedItem()).trim();

    String algorithmKey = switch (selected) {
        case "First-In First-Out (FIFO/FCFS)" -> "FIFO";
        case "Shortest Job First (SJF) Non-Preemptive" -> "SJF";
        case "Shortest Remaining Time First (SRTF) Preemptive" -> "SRTF";
        case "Round Robin (RR)" -> "RR";
        case "Multilevel Feedback Queue (MLFQ)" -> "MLFQ";
        default -> "UNKNOWN";
    };

    if (!algorithmKey.equals(selectedAlgorithm)) {
        selectedAlgorithm = algorithmKey;
        processList.clear();

        // Clear progress bars
        processPanel.removeAll();
        processPanel.revalidate();
        processPanel.repaint();

        // Clear table
        ((javax.swing.table.DefaultTableModel) jTable1.getModel()).setRowCount(0);

        // Clear queue panel
        queuePanel.removeAll();
        queuePanel.revalidate();
        queuePanel.repaint();

        // Clear Gantt chart
        ganttPanel.removeAll();
        ganttPanel.revalidate();
        ganttPanel.repaint();

        UserInput.setText("");
        RunButton.setSelected(false);
        JOptionPane.showMessageDialog(this, "Switched to: " + selected + ". Enter new process info.");
    }
        
    }//GEN-LAST:event_jComboBox1ActionPerformed

    private void EnterActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_EnterActionPerformed
        // TODO add your handling code here:
    processPanel.removeAll();  // Clear UI
    processList = new ArrayList<>(); // Reset data list

    int numProcesses;
    try {
        numProcesses = Integer.parseInt(UserInput.getText());
        if (numProcesses < 1 || numProcesses > 20) {
            throw new NumberFormatException();
        }
    } catch (NumberFormatException ex) {
        JOptionPane.showMessageDialog(this, "Enter a valid number between 1 and 20.");
        return;
    }

    for (int i = 1; i <= numProcesses; i++) {
        try {
            String arrivalStr = JOptionPane.showInputDialog("Enter Arrival Time for P" + i + ":");
            if (arrivalStr == null) {
                JOptionPane.showMessageDialog(this, "Input cancelled. Returning to main screen.");
                return; // exit the method gracefully
            }

            int arrival = Integer.parseInt(arrivalStr);

            String burstStr = JOptionPane.showInputDialog("Enter Burst Time for P" + i + ":");
            if (burstStr == null) {
                JOptionPane.showMessageDialog(this, "Input cancelled. Returning to main screen.");
                return;
            }

            int burst = Integer.parseInt(burstStr);

            // Create and store process
            Process p = new Process(i, arrival, burst);

            // Create corresponding row in UI
            JPanel row = new JPanel(new BorderLayout(5, 5));
            JLabel pidLabel = new JLabel("P" + i);
            JProgressBar progressBar = new JProgressBar();
            progressBar.setStringPainted(true);
            progressBar.setValue(0);
            JLabel stateLabel = new JLabel("Ready");

            // Attach components to process
            p.progressBar = progressBar;
            p.stateLabel = stateLabel;

            // Add to list and panel
            processList.add(p);
            row.add(pidLabel, BorderLayout.WEST);
            row.add(progressBar, BorderLayout.CENTER);
            row.add(stateLabel, BorderLayout.EAST);
            stateLabel.setBorder(javax.swing.BorderFactory.createEmptyBorder(0, 0, 0, 15));

            processPanel.add(row);
        } catch (NumberFormatException e) {
            JOptionPane.showMessageDialog(this, "Invalid input. Please enter numeric values.");
            i--; // Retry this process
        }
    }

    processPanel.revalidate();
    processPanel.repaint();
    }//GEN-LAST:event_EnterActionPerformed

    private void UserInputActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_UserInputActionPerformed
        // TODO add your handling code here:
       
    }//GEN-LAST:event_UserInputActionPerformed

    private void RunButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_RunButtonActionPerformed
         if (processList == null || processList.isEmpty()) {
        JOptionPane.showMessageDialog(this, "Please enter processes first.");
        return;
    }

    // Disable input during run
    Enter.setEnabled(false);
    UserInput.setEnabled(false);
    RunButton.setEnabled(false);

    // Run selected algorithm
    switch (selectedAlgorithm) {
        case "FIFO":
            runFIFO();
            break;
        case "SJF":
            runSJF();
            break;
        case "SRTF":
            runSRTF();
            break;
        case "RR":
            runRR();
            break;
        case "MLFQ":
            runMLFQ();
            break;
        default:
            JOptionPane.showMessageDialog(this, "Unknown algorithm selected.");
            Enter.setEnabled(true);
            UserInput.setEnabled(true);
            RunButton.setEnabled(true);
         } 
    }//GEN-LAST:event_RunButtonActionPerformed

    private void resetButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_resetButtonActionPerformed
        // TODO add your handling code here:
  processList.clear();

    processPanel.removeAll();
    processPanel.revalidate();
    processPanel.repaint();

    queuePanel.removeAll();
    queuePanel.revalidate();
    queuePanel.repaint();

    ganttPanel.removeAll();
    ganttPanel.revalidate();
    ganttPanel.repaint();

    javax.swing.table.DefaultTableModel model = (javax.swing.table.DefaultTableModel) jTable1.getModel();
    model.setRowCount(0);

    // Reset input controls
    UserInput.setEnabled(true);
    UserInput.setText("");
    Enter.setEnabled(true);
    RunButton.setEnabled(true);
    RunButton.setSelected(false);
    resetButton.setEnabled(true);
        
    }//GEN-LAST:event_resetButtonActionPerformed
    private void logAction(String message) {
    SwingUtilities.invokeLater(() -> {
        actionLog.append(message + "\n");
        actionLog.setCaretPosition(actionLog.getDocument().getLength());
    });
}
    
    private void runFIFO() {
     resetButton.setEnabled(false); // ⛔ Disable reset
     
     SwingUtilities.invokeLater(() -> actionLog.setText(""));
     logAction("▶️ [ FIFO Scheduling] started");

    processList.sort((p1, p2) -> Integer.compare(p1.arrivalTime, p2.arrivalTime));

    SwingUtilities.invokeLater(() -> {
        updateQueueDisplay(processList);
        ganttPanel.removeAll();
        ganttPanel.revalidate();
        ganttPanel.repaint();
    });

    new Thread(() -> {
        int[] currentTime = {0};
        int[] totalTAT = {0};
        int[] totalRT = {0};

        for (int i = 0; i < processList.size(); i++) {
            Process p = processList.get(i);

            if (p.burstTime == 0) {
                int finalIndex = i;
                SwingUtilities.invokeLater(() -> {
                    p.progressBar.setValue(100);
                    p.stateLabel.setText("Done");
                    updateGanttChart(p.arrivalTime, p.arrivalTime, p.pid);
                    updateQueueDisplay(processList.subList(finalIndex + 1, processList.size()));
                    if (finalIndex == processList.size() - 1) {
                        updateTable(totalTAT[0], totalRT[0]);
                        Enter.setEnabled(true);
                        UserInput.setEnabled(true);
                        RunButton.setEnabled(true);
                        RunButton.setSelected(false);
                        resetButton.setEnabled(true);
                    }
                });
                continue;
            }

            if (currentTime[0] < p.arrivalTime) {
                try {
                    Thread.sleep((p.arrivalTime - currentTime[0]) * simulationDelay);
                } catch (InterruptedException e) {}
                currentTime[0] = p.arrivalTime;
            }

            int finalI = i;
            SwingUtilities.invokeLater(() -> {
                List<Process> remainingQueue = processList.subList(finalI, processList.size());
                updateQueueDisplay(remainingQueue);
            });

            int finalIndex = i;
            int startTime = currentTime[0];
            logAction("FIFO: " + p.pid + " started at " + startTime);
            int burst = p.burstTime;

            SwingWorker<Void, Integer> worker = new SwingWorker<>() {
                @Override
                protected Void doInBackground() throws Exception {
                    p.stateLabel.setText("Running");
                    for (int t = 1; t <= burst; t++) {
                        Thread.sleep(simulationDelay);
                        publish(t * 100 / burst);
                    }
                    publish(100);
                    return null;
                }

                @Override
                protected void process(List<Integer> chunks) {
                    int value = chunks.get(chunks.size() - 1);
                    p.progressBar.setValue(value);
                }

                @Override
                protected void done() {
                    SwingUtilities.invokeLater(() -> {
                        p.progressBar.setValue(100);
                        p.stateLabel.setText("Done");

                        currentTime[0] = startTime + burst;
                        p.responseTime = startTime - p.arrivalTime;
                        p.completionTime = currentTime[0];
                        logAction("FIFO: " + p.pid + " completed at " + currentTime[0]);
                        p.turnaroundTime = p.completionTime - p.arrivalTime;

                        totalRT[0] += p.responseTime;
                        totalTAT[0] += p.turnaroundTime;

                        updateGanttChart(startTime, currentTime[0], p.pid);

                        if (finalIndex + 1 < processList.size()) {
                            updateQueueDisplay(processList.subList(finalIndex + 1, processList.size()));
                        } else {
                            updateQueueDisplay(new ArrayList<>());
                        }

                        if (finalIndex == processList.size() - 1) {
                            updateTable(totalTAT[0], totalRT[0]);
                            Enter.setEnabled(true);
                            UserInput.setEnabled(true);
                            RunButton.setEnabled(true);
                            RunButton.setSelected(false);
                            resetButton.setEnabled(true); // ✅ Re-enable reset
                            logAction("[FIFO Scheduling] Completed!");
                        }
                    });
                }
            };

            worker.execute();

            try {
                while (!worker.isDone()) {
                    Thread.sleep(simulationDelay);
                }
            } catch (InterruptedException e) {}
        }
    }).start();
}
    
    private void runSJF() {
    resetButton.setEnabled(false); // ⛔ Disable reset during simulation

    SwingUtilities.invokeLater(() -> actionLog.setText(""));
    logAction("▶️ [SJF Scheduling] started");

    new Thread(() -> {
        List<Process> readyQueue = new ArrayList<>();
        int time = 0;
        int completed = 0;
        int n = processList.size();
        int[] totalRT = {0};
        int[] totalTAT = {0};

        for (Process p : processList) {
            p.remainingTime = p.burstTime;
            p.started = false;
        }

        processList.sort((p1, p2) -> {
            if (p1.arrivalTime != p2.arrivalTime) {
                return Integer.compare(p1.arrivalTime, p2.arrivalTime);
            }
            return Integer.compare(p1.burstTime, p2.burstTime);
        });

        SwingUtilities.invokeLater(() -> {
            ganttPanel.removeAll();
            ganttPanel.revalidate();
            ganttPanel.repaint();
        });

        while (completed < n) {
            readyQueue.clear();
            for (Process p : processList) {
                if (!p.started && p.arrivalTime <= time) {
                    readyQueue.add(p);
                }
            }

            List<Process> displayQueue = new ArrayList<>(readyQueue);
            SwingUtilities.invokeLater(() -> updateQueueDisplay(displayQueue));

            if (readyQueue.isEmpty()) {
                time++;
                try {
                    Thread.sleep(simulationDelay);
                } catch (InterruptedException ignored) {}
                continue;
            }

            readyQueue.sort((p1, p2) -> Integer.compare(p1.burstTime, p2.burstTime));
            Process current = readyQueue.get(0);
            current.started = true;

            if (current.burstTime == 0) {
                int finalTime = time;
                SwingUtilities.invokeLater(() -> {
                    current.stateLabel.setText("Done");
                    current.progressBar.setValue(100);
                    updateGanttChart(finalTime, finalTime, current.pid);
                    updateQueueDisplay(new ArrayList<>());
                });
                current.responseTime = 0;
                current.completionTime = time;
                current.turnaroundTime = 0;
                totalRT[0] += current.responseTime;
                totalTAT[0] += current.turnaroundTime;
                completed++;
                continue;
            }
            
            logAction("SJF: " + current.pid + " started at " + time);
            int start = time;
            int end = time + current.burstTime;

            current.responseTime = start - current.arrivalTime;
            current.completionTime = end;
            current.turnaroundTime = end - current.arrivalTime;
            totalRT[0] += current.responseTime;
            totalTAT[0] += current.turnaroundTime;

            Process finalCurrent = current;
            SwingUtilities.invokeLater(() -> finalCurrent.stateLabel.setText("Running"));

            for (int t = 0; t < current.burstTime; t++) {
                try {
                    Thread.sleep(simulationDelay);
                } catch (InterruptedException ignored) {}

                int progress = (int) (((t + 1) / (float) current.burstTime) * 100);
                SwingUtilities.invokeLater(() -> finalCurrent.progressBar.setValue(progress));

                int finalTime = time + t + 1;
                List<Process> tickQueue = new ArrayList<>();
                for (Process p : processList) {
                    if (!p.started && p.arrivalTime <= finalTime) {
                        tickQueue.add(p);
                    }
                }
                SwingUtilities.invokeLater(() -> updateQueueDisplay(tickQueue));
            }

            SwingUtilities.invokeLater(() -> {
                finalCurrent.stateLabel.setText("Done");
                finalCurrent.progressBar.setValue(100);
                updateGanttChart(start, end, finalCurrent.pid);
            });

            time = end;
            completed++;
            logAction("SJF: " + current.pid + " completed at " + time);
        }

        SwingUtilities.invokeLater(() -> {
            updateTable(totalTAT[0], totalRT[0]);
            Enter.setEnabled(true);
            UserInput.setEnabled(true);
            RunButton.setEnabled(true);
            RunButton.setSelected(false);
            resetButton.setEnabled(true); // ✅ Re-enable reset
            logAction("[SJF Scheduling] Completed!");
        });
    }).start();
}

    
    private void runSRTF() {
        
    SwingUtilities.invokeLater(() -> actionLog.setText(""));
    logAction("▶️ [SRTF Scheduling] started");
        
   new Thread(() -> {
        List<Process> readyQueue = new ArrayList<>();
        int time = 0;
        int completed = 0;
        int n = processList.size();
        int[] totalRT = {0};
        int[] totalTAT = {0};

        for (Process p : processList) {
            p.remainingTime = p.burstTime;
            p.started = false;
        }
        
        for (Process p : processList) {
    if (p.burstTime == 0) {
        p.remainingTime = 0;
        p.completionTime = p.arrivalTime;
        p.turnaroundTime = 0;
        p.responseTime = 0;
        totalRT[0] += p.responseTime;
        totalTAT[0] += p.turnaroundTime;
        completed++;

        Process finalP = p;
        SwingUtilities.invokeLater(() -> {
            finalP.stateLabel.setText("Done");
            finalP.progressBar.setValue(100);
            updateGanttChart(finalP.arrivalTime, finalP.arrivalTime, finalP.pid);
        });
    }
}
        
        SwingUtilities.invokeLater(() -> {
            ganttPanel.removeAll();
            ganttPanel.revalidate();
            ganttPanel.repaint();
        });

        Process current = null;
        int start = -1;

        while (completed < n) {
            for (Process p : processList) {
                if (p.arrivalTime == time) {
                    readyQueue.add(p);
                }
            }

            Process shortest = null;
            for (Process p : readyQueue) {
                if (p.remainingTime > 0) {
                    if (shortest == null || p.remainingTime < shortest.remainingTime) {
                        shortest = p;
                    }
                }
            }

            if (shortest != null) {
                logAction("SRTF: Switched to " + shortest.pid + " at time " + time);
                if (current != shortest) {
                    if (current != null && current.remainingTime > 0) {
                        Process finalOld = current;
                        SwingUtilities.invokeLater(() -> finalOld.stateLabel.setText("Ready"));
                    }

                    current = shortest;
                    start = time;

                    if (!current.started) {
                        current.started = true;
                        current.responseTime = time - current.arrivalTime;
                    }

                    Process finalCurrentStart = current;
                    SwingUtilities.invokeLater(() -> finalCurrentStart.stateLabel.setText("Running"));
                }

                Process finalCurrentTick = current;
                SwingUtilities.invokeLater(() -> {
                    finalCurrentTick.progressBar.setValue(
                        (int)(((finalCurrentTick.burstTime - finalCurrentTick.remainingTime + 1) * 100.0) / finalCurrentTick.burstTime)
                    );
                });

                current.remainingTime--;

                if (current.remainingTime == 0) {
                    Process finalCurrentDone = current;
                    int finalStart = start;
                    int finalEnd = time + 1;

                    current.completionTime = finalEnd;
                    current.turnaroundTime = finalCurrentDone.completionTime - finalCurrentDone.arrivalTime;
                    totalRT[0] += finalCurrentDone.responseTime;
                    totalTAT[0] += finalCurrentDone.turnaroundTime;

                    readyQueue.remove(current);

                    SwingUtilities.invokeLater(() -> {
                        finalCurrentDone.stateLabel.setText("Done");
                        finalCurrentDone.progressBar.setValue(100);
                        updateGanttChart(finalStart, finalEnd, finalCurrentDone.pid);
                        
                        logAction("SRTF: " + finalCurrentDone.pid + " completed at time " + finalEnd);
                    });

                    current = null;
                    completed++;
                }
            }

            Set<Integer> seenPIDs = new HashSet<>();
            List<Process> displayQueue = new ArrayList<>();
            for (Process p : readyQueue) {
                if (p.remainingTime > 0 && p != current && seenPIDs.add(p.pid)) {
                    displayQueue.add(p);
                }
            }

            SwingUtilities.invokeLater(() -> updateQueueDisplay(displayQueue));

            try {
                Thread.sleep(simulationDelay);
            } catch (InterruptedException ignored) {}

            time++;
        }

        SwingUtilities.invokeLater(() -> {
            updateTable(totalTAT[0], totalRT[0]);
            reenableControls(); // ✅ reset button enabled here
            ganttPanel.revalidate(); // 🔄 Force Gantt sync
            ganttPanel.repaint();
            logAction("✅ [SRTF Scheduling] completed"); 
        });
    }).start();
}
    
    private void runRR() {
    SwingUtilities.invokeLater(() -> actionLog.setText(""));
    logAction("▶️ [Round Robin Scheduling] started");

    String input = JOptionPane.showInputDialog(this, "Enter Time Quantum:", "Round Robin Settings", JOptionPane.QUESTION_MESSAGE);
    if (input == null) {
        reenableControls();
        return;
    }

    int timeQuantum;
    try {
        timeQuantum = Integer.parseInt(input);
        if (timeQuantum <= 0) throw new NumberFormatException();
    } catch (NumberFormatException e) {
        JOptionPane.showMessageDialog(this, "Invalid input. Please enter a positive integer.", "Error", JOptionPane.ERROR_MESSAGE);
        reenableControls();
        return;
    }

    logAction("⏱ Time Quantum: " + timeQuantum);
    resetButton.setEnabled(false);

    boolean allZeroBurst = processList.stream().allMatch(p -> p.burstTime == 0);
    if (allZeroBurst) {
        int choice = JOptionPane.showConfirmDialog(
            this,
            "All burst times are 0 — no execution will take place.\nProceed anyway?",
            "Warning",
            JOptionPane.YES_NO_OPTION,
            JOptionPane.WARNING_MESSAGE
        );
        if (choice != JOptionPane.YES_OPTION) {
            reenableControls();
            return;
        }
    }

    new Thread(() -> {
        List<Process> readyQueue = new ArrayList<>();
        int time = 0, completed = 0, n = processList.size();
        int[] totalRT = {0}, totalTAT = {0};

        for (Process p : processList) {
            p.remainingTime = p.burstTime;
            p.started = false;
        }

        // ✅ Log immediately finished (burstTime == 0) processes
        for (Process p : processList) {
            if (p.burstTime == 0) {
                p.remainingTime = 0;
                p.completionTime = p.arrivalTime;
                p.responseTime = 0;
                p.turnaroundTime = 0;
                totalRT[0] += p.responseTime;
                totalTAT[0] += p.turnaroundTime;
                completed++;

                Process finalP = p;
                SwingUtilities.invokeLater(() -> {
                    finalP.stateLabel.setText("Done");
                    finalP.progressBar.setValue(100);
                    updateGanttChart(finalP.arrivalTime, finalP.arrivalTime, finalP.pid);
                    logAction("⚡ " + finalP.pid + " completed instantly (burst time = 0)");
                });
            }
        }

        SwingUtilities.invokeLater(() -> {
            ganttPanel.removeAll();
            ganttPanel.revalidate();
            ganttPanel.repaint();
        });

        while (completed < n) {
            for (Process p : processList) {
                if (p.arrivalTime <= time && p.remainingTime > 0 && !queueContains(readyQueue, p)) {
                    readyQueue.add(p);
                }
            }

            if (readyQueue.isEmpty()) {
                time++;
                try { Thread.sleep(simulationDelay); } catch (InterruptedException ignored) {}
                continue;
            }

            Process current = readyQueue.remove(0);
            if (current.remainingTime <= 0) continue;

            int execTime = Math.min(timeQuantum, current.remainingTime);
            int startTime = time;

            if (!current.started) {
                current.started = true;
                current.responseTime = time - current.arrivalTime;
                totalRT[0] += current.responseTime;
            }

            logAction("▶️ " + current.pid + " started at " + startTime);

            Process finalCurrent = current;
            SwingUtilities.invokeLater(() -> finalCurrent.stateLabel.setText("Running"));

            for (int i = 0; i < execTime; i++) {
                try { Thread.sleep(simulationDelay); } catch (InterruptedException ignored) {}
                time++;
                current.remainingTime--;

                int progress = (int)(((float)(current.burstTime - current.remainingTime) / current.burstTime) * 100);
                SwingUtilities.invokeLater(() -> current.progressBar.setValue(progress));

                for (Process p : processList) {
                    if (p.arrivalTime == time && p.remainingTime > 0 && !queueContains(readyQueue, p)) {
                        readyQueue.add(p);
                    }
                }
            }

            int endTime = time;

            if (startTime != endTime) {
                SwingUtilities.invokeLater(() -> {
                    finalCurrent.stateLabel.setText(finalCurrent.remainingTime == 0 ? "Done" : "Ready");
                    if (finalCurrent.remainingTime == 0) finalCurrent.progressBar.setValue(100);
                    updateGanttChart(startTime, endTime, finalCurrent.pid);
                });
            }

            if (current.remainingTime > 0) {
                if (!queueContains(readyQueue, current)) {
                    readyQueue.add(current);
                }
                logAction("🔁 " + current.pid + " paused at " + endTime + " (remaining: " + current.remainingTime + ")");
            } else {
                current.completionTime = time;
                current.turnaroundTime = current.completionTime - current.arrivalTime;
                totalTAT[0] += current.turnaroundTime;
                completed++;
                logAction("✅ " + current.pid + " completed at " + time);
            }

            List<Process> queueDisplay = new ArrayList<>();
            for (Process p : readyQueue) {
                if (p.remainingTime > 0 && !queueDisplay.contains(p)) {
                    queueDisplay.add(p);
                }
            }

            SwingUtilities.invokeLater(() -> updateQueueDisplay(queueDisplay));
        }

        SwingUtilities.invokeLater(() -> {
            updateTable(totalTAT[0], totalRT[0]);
            reenableControls();
            ganttPanel.revalidate();
            ganttPanel.repaint();
            logAction("✔️ All processes completed (RR).");
        });
    }).start();
}

    
    private void runMLFQ() {
    SwingUtilities.invokeLater(() -> actionLog.setText(""));
    logAction("▶️ [MLFQ Scheduling] started");

    String[] quantumInput = new String[4];
    for (int i = 0; i < 4; i++) {
        quantumInput[i] = JOptionPane.showInputDialog(this,
            "Enter Time Quantum for Q" + i + ":", "MLFQ Quantum Input", JOptionPane.QUESTION_MESSAGE);
        if (quantumInput[i] == null) {
            reenableControls();
            return;
        }
    }

    int[] quantum = new int[4];
    try {
        for (int i = 0; i < 4; i++) {
            quantum[i] = Integer.parseInt(quantumInput[i].trim());
            if (quantum[i] <= 0) throw new NumberFormatException();
        }
    } catch (NumberFormatException e) {
        JOptionPane.showMessageDialog(this, "Invalid quantum input. Please enter valid positive integers.",
                "Error", JOptionPane.ERROR_MESSAGE);
        reenableControls();
        return;
    }

    String[] allotmentInput = new String[4];
    for (int i = 0; i < 4; i++) {
        allotmentInput[i] = JOptionPane.showInputDialog(this,
            "Enter Allotment Time for Q" + i + ":", "MLFQ Allotment Input", JOptionPane.QUESTION_MESSAGE);
        if (allotmentInput[i] == null) {
            reenableControls();
            return;
        }
    }

    int[] allotments = new int[4];
    try {
        for (int i = 0; i < 4; i++) {
            allotments[i] = Integer.parseInt(allotmentInput[i].trim());
            if (allotments[i] <= 0) throw new NumberFormatException();
        }
    } catch (NumberFormatException e) {
        JOptionPane.showMessageDialog(this, "Invalid allotment input. Please enter valid positive integers.",
                "Error", JOptionPane.ERROR_MESSAGE);
        reenableControls();
        return;
    }

    resetButton.setEnabled(false);

    boolean allZeroBurst = processList.stream().allMatch(p -> p.burstTime == 0);
    if (allZeroBurst) {
        int choice = JOptionPane.showConfirmDialog(this,
                "All burst times are 0 — no execution will take place.\nProceed anyway?",
                "Warning", JOptionPane.YES_NO_OPTION, JOptionPane.WARNING_MESSAGE);
        if (choice != JOptionPane.YES_OPTION) {
            reenableControls();
            return;
        }
    }

    new Thread(() -> {
        List<Queue<Process>> queues = new ArrayList<>();
        for (int i = 0; i < 4; i++) queues.add(new LinkedList<>());

        Map<Process, Integer> allotmentUsed = new HashMap<>();
        int time = 0, completed = 0, n = processList.size();
        int[] totalRT = {0}, totalTAT = {0};

        for (Process p : processList) {
            p.remainingTime = p.burstTime;
            p.started = false;
            p.currentQueueLevel = 0;
        }

        for (Process p : processList) {
            if (p.burstTime == 0) {
                p.remainingTime = 0;
                p.completionTime = p.arrivalTime;
                p.responseTime = 0;
                p.turnaroundTime = 0;
                totalRT[0] += p.responseTime;
                totalTAT[0] += p.turnaroundTime;
                completed++;

                Process finalP = p;
                SwingUtilities.invokeLater(() -> {
                    finalP.stateLabel.setText("Done");
                    finalP.progressBar.setValue(100);
                    updateGanttChart(finalP.arrivalTime, finalP.arrivalTime, finalP.pid, finalP.currentQueueLevel);
                    logAction("✅ P" + finalP.pid + " completed immediately (burst=0)");
                });
            }
        }

        SwingUtilities.invokeLater(() -> {
            ganttPanel.removeAll();
            ganttPanel.revalidate();
            ganttPanel.repaint();
        });

        while (completed < n) {
            for (Process p : processList) {
                if (p.arrivalTime == time && p.remainingTime > 0) {
                    queues.get(0).add(p);
                    logAction("📥 P" + p.pid + " arrived and placed in Q0");
                }
            }

            Process current = null;
            int currentQueue = -1;
            for (int q = 0; q < 4; q++) {
                if (!queues.get(q).isEmpty()) {
                    current = queues.get(q).poll();
                    currentQueue = q;
                    break;
                }
            }

            if (current == null) {
                time++;
                try { Thread.sleep(simulationDelay); } catch (InterruptedException ignored) {}
                continue;
            }

            if (!current.started) {
                current.started = true;
                current.responseTime = time - current.arrivalTime;
                totalRT[0] += current.responseTime;
                logAction("🕒 P" + current.pid + " starts at time " + time + " (Q" + currentQueue + ")");
            }

            allotmentUsed.putIfAbsent(current, 0);
            int execTime = Math.min(quantum[currentQueue], current.remainingTime);
            int startTime = time;

            Process finalCurrent = current;
            int finalQueue = currentQueue;
            SwingUtilities.invokeLater(() -> finalCurrent.stateLabel.setText("Running"));

            for (int i = 0; i < execTime; i++) {
                time++;
                current.remainingTime--;

                int progress = (int)(((float)(current.burstTime - current.remainingTime) / current.burstTime) * 100);
                SwingUtilities.invokeLater(() -> finalCurrent.progressBar.setValue(progress));

                for (Process p : processList) {
                    if (p.arrivalTime == time && p.remainingTime > 0) {
                        queues.get(0).add(p);
                        logAction("📥 P" + p.pid + " arrived at time " + time + " → Q0");
                    }
                }

                try { Thread.sleep(simulationDelay); } catch (InterruptedException ignored) {}
                if (current.remainingTime == 0) break;
            }

            int endTime = time;
            boolean isDone = current.remainingTime == 0;

            int duration = endTime - startTime;

            SwingUtilities.invokeLater(() -> {
                finalCurrent.stateLabel.setText(isDone ? "Done" : "Ready");
                if (isDone) finalCurrent.progressBar.setValue(100);
                updateGanttChart(startTime, endTime, finalCurrent.pid, finalQueue);
            });

            if (!isDone) {
                int used = allotmentUsed.get(current) + duration;
                allotmentUsed.put(current, used);

                if (currentQueue < 3 && used >= allotments[currentQueue]) {
                    int nextQueue = currentQueue + 1;
                    current.currentQueueLevel = nextQueue;
                    queues.get(nextQueue).add(current);
                    logAction("🔽 P" + current.pid + " demoted to Q" + nextQueue);
                } else {
                    queues.get(currentQueue).add(current);
                    logAction("🔁 P" + current.pid + " returns to Q" + currentQueue);
                }
            } else {
                current.completionTime = time;
                current.turnaroundTime = current.completionTime - current.arrivalTime;
                totalTAT[0] += current.turnaroundTime;
                completed++;
                logAction("✅ P" + current.pid + " finished at time " + time);
            }

            List<Process> displayQueue = new ArrayList<>();
            for (Queue<Process> q : queues) {
                for (Process p : q) {
                    if (p.remainingTime > 0 && !displayQueue.contains(p)) {
                        displayQueue.add(p);
                    }
                }
            }

            SwingUtilities.invokeLater(() -> updateQueueDisplay(displayQueue));
        }

        SwingUtilities.invokeLater(() -> {
            updateTable(totalTAT[0], totalRT[0]);
            ganttPanel.revalidate();
            ganttPanel.repaint();
            updateQueueDisplay(new ArrayList<>());
            reenableControls();
            logAction("🏁 MLFQ Scheduling finished");
        });
    }).start();
}



// Utility method to re-enable UI buttons
private void reenableControls() {
    Enter.setEnabled(true);
    UserInput.setEnabled(true);
    RunButton.setEnabled(true);
    RunButton.setSelected(false);
    resetButton.setEnabled(true);
}

    
    private void updateTable(int totalTAT, int totalRT) {
    javax.swing.table.DefaultTableModel model = (javax.swing.table.DefaultTableModel) jTable1.getModel();
    model.setRowCount(0);

    for (Process p : processList) {
        model.addRow(new Object[] {
            "P" + p.pid, p.arrivalTime, p.burstTime, p.completionTime,
            p.turnaroundTime, p.responseTime, "", ""
        });
    }

    float avgTAT = (float) totalTAT / processList.size();
    float avgRT = (float) totalRT / processList.size();

    model.addRow(new Object[] {
        "", "", "", "", "", "", String.format("%.2f", avgTAT), String.format("%.2f", avgRT)
    });
}
    
    private void updateQueueDisplay(List<Process> queue) {
    queuePanel.removeAll();
    for (Process p : queue) {
        JLabel label = new JLabel("P" + p.pid);
        label.setBorder(javax.swing.BorderFactory.createLineBorder(java.awt.Color.BLACK));
        label.setHorizontalAlignment(JLabel.CENTER);
        label.setOpaque(true);
        label.setBackground(java.awt.Color.LIGHT_GRAY);
        queuePanel.add(label);
    }
    queuePanel.revalidate();
    queuePanel.repaint();
}
    
    private void updateGanttChart(int startTime, int endTime, int pid) {
   JPanel block = new JPanel();
    block.setBorder(BorderFactory.createLineBorder(Color.BLACK));
    block.setBackground(Color.YELLOW);
    block.setLayout(new BoxLayout(block, BoxLayout.Y_AXIS));

    JLabel pidLabel = new JLabel("P" + pid);
    pidLabel.setFont(new Font("Arial", Font.BOLD, 14));
    pidLabel.setAlignmentX(Component.CENTER_ALIGNMENT);

    JLabel timeLabel = new JLabel("Running...");
    timeLabel.setFont(new Font("Arial", Font.PLAIN, 12));
    timeLabel.setAlignmentX(Component.CENTER_ALIGNMENT);

    block.add(Box.createVerticalGlue());
    block.add(pidLabel);
    block.add(timeLabel);
    block.add(Box.createVerticalGlue());

    int blockWidth = Math.max((endTime - startTime) * 30, 50);
    block.setPreferredSize(new Dimension(blockWidth, ganttPanel.getHeight()));
    int finalBlockWidth = blockWidth;

    SwingUtilities.invokeLater(() -> {
        ganttPanel.add(block);
        int totalBlocks = ganttPanel.getComponentCount();
        int totalWidth = totalBlocks * (finalBlockWidth + 5);
        ganttPanel.setPreferredSize(new Dimension(totalWidth, ganttPanel.getHeight()));
        ganttPanel.revalidate();
        ganttPanel.repaint();
    });

    new Thread(() -> {
        try {
            Thread.sleep(500);
        } catch (InterruptedException ignored) {}
        SwingUtilities.invokeLater(() -> {
            block.setBackground(Color.CYAN);
            timeLabel.setText(startTime + " - " + endTime);
        });
    }).start();
}
    
    // Overloaded method for MLFQ that shows queue level
private void updateGanttChart(int startTime, int endTime, int pid, int queueLevel) {
    JPanel block = new JPanel();
    block.setBorder(BorderFactory.createLineBorder(Color.BLACK));

    // 🎨 Optional: set color based on queue level
    Color[] queueColors = { Color.RED, Color.ORANGE, Color.GREEN, Color.BLUE };
    block.setBackground(queueLevel >= 0 && queueLevel < queueColors.length ? queueColors[queueLevel] : Color.LIGHT_GRAY);

    block.setLayout(new BoxLayout(block, BoxLayout.Y_AXIS)); // vertical layout

    // PID + Queue Label
    JLabel pidLabel = new JLabel(queueLevel >= 0 ? "P" + pid + " (Q" + queueLevel + ")" : "P" + pid);
    pidLabel.setFont(new Font("Arial", Font.BOLD, 14));
    pidLabel.setAlignmentX(Component.CENTER_ALIGNMENT);
    pidLabel.setHorizontalAlignment(SwingConstants.CENTER);

    // Time Label
    JLabel timeLabel = new JLabel("Running...");
    timeLabel.setFont(new Font("Arial", Font.PLAIN, 12));
    timeLabel.setAlignmentX(Component.CENTER_ALIGNMENT);
    timeLabel.setHorizontalAlignment(SwingConstants.CENTER);

    block.add(Box.createVerticalGlue());
    block.add(pidLabel);
    block.add(timeLabel);
    block.add(Box.createVerticalGlue());

    int blockWidth = Math.max((endTime - startTime) * 30, 50);
    block.setPreferredSize(new Dimension(blockWidth, ganttPanel.getHeight()));

    SwingUtilities.invokeLater(() -> {
        ganttPanel.add(block);
        ganttPanel.revalidate();
        ganttPanel.repaint();
    });

    // Animate and change to cyan after running
    new Thread(() -> {
        try {
            Thread.sleep((endTime - startTime) * 500);
        } catch (InterruptedException ignored) {}

        SwingUtilities.invokeLater(() -> {
            block.setBackground(Color.CYAN);
            timeLabel.setText(startTime + " - " + endTime);
        });
    }).start();

    // Resize the Gantt panel if needed
    SwingUtilities.invokeLater(() -> {
        int totalBlocks = ganttPanel.getComponentCount();
        int totalWidth = totalBlocks * (blockWidth + 5);
        ganttPanel.setPreferredSize(new Dimension(totalWidth, ganttPanel.getHeight()));
        ganttPanel.revalidate();
        ganttPanel.repaint();
    });
}


private boolean queueContains(List<Process> queue, Process target) {
    for (Process p : queue) {
        if (p.pid == target.pid) return true;
    }
    return false;
}
    /**
     * @param args the command line arguments
     */
    public static void main(String args[]) {
        /* Set the Nimbus look and feel */
        //<editor-fold defaultstate="collapsed" desc=" Look and feel setting code (optional) ">
        /* If Nimbus (introduced in Java SE 6) is not available, stay with the default look and feel.
         * For details see http://download.oracle.com/javase/tutorial/uiswing/lookandfeel/plaf.html 
         */
        try {
            for (javax.swing.UIManager.LookAndFeelInfo info : javax.swing.UIManager.getInstalledLookAndFeels()) {
                if ("Nimbus".equals(info.getName())) {
                    javax.swing.UIManager.setLookAndFeel(info.getClassName());
                    break;
                }
            }
        } catch (ClassNotFoundException ex) {
            java.util.logging.Logger.getLogger(NewJFrame.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (InstantiationException ex) {
            java.util.logging.Logger.getLogger(NewJFrame.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (IllegalAccessException ex) {
            java.util.logging.Logger.getLogger(NewJFrame.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (javax.swing.UnsupportedLookAndFeelException ex) {
            java.util.logging.Logger.getLogger(NewJFrame.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        }
        //</editor-fold>

        /* Create and display the form */
        java.awt.EventQueue.invokeLater(new Runnable() {
            public void run() {
                new NewJFrame().setVisible(true);
            }
        });
    }

    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JLabel AlgorithmLabel;
    private javax.swing.JButton Enter;
    private javax.swing.JLabel HowManyProcessLabel;
    private javax.swing.JLabel PIDLabel;
    private javax.swing.JLabel ProgressLabel;
    private javax.swing.JLabel QueueLabel;
    private javax.swing.JToggleButton RunButton;
    private javax.swing.JLabel SimulationSpeedLabel;
    private javax.swing.JLabel StateLabel;
    private javax.swing.JTextField UserInput;
    private javax.swing.JTextArea actionLog;
    private javax.swing.JPanel ganttPanel;
    private javax.swing.JComboBox<String> jComboBox1;
    private javax.swing.JLabel jLabel1;
    private javax.swing.JLabel jLabel2;
    private javax.swing.JLabel jLabel3;
    private javax.swing.JLabel jLabel6;
    private javax.swing.JScrollPane jScrollPane1;
    private javax.swing.JScrollPane jScrollPane2;
    private javax.swing.JScrollPane jScrollPane3;
    private javax.swing.JScrollPane jScrollPane4;
    private javax.swing.JScrollPane jScrollPane5;
    private javax.swing.JTable jTable1;
    private javax.swing.JPanel processPanel;
    private javax.swing.JPanel queuePanel;
    private javax.swing.JButton resetButton;
    private javax.swing.JSlider simulationSpeed;
    // End of variables declaration//GEN-END:variables
}
